// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: gadget.capnp

#pragma once

#include <capnp/generated-header-support.h>
#include <kj/windows-sanity.h>
#if !CAPNP_LITE
#include <capnp/capability.h>
#endif  // !CAPNP_LITE

#if CAPNP_VERSION != 8000
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif


namespace capnp {
namespace schemas {

CAPNP_DECLARE_SCHEMA(b522a997799c0d00);
CAPNP_DECLARE_SCHEMA(9c312e7f89b7f157);
CAPNP_DECLARE_SCHEMA(ace0e474025dc6a2);
CAPNP_DECLARE_SCHEMA(e71a04084cc54a1a);
CAPNP_DECLARE_SCHEMA(8957f59f216dc578);
CAPNP_DECLARE_SCHEMA(bea209a4d3b01d5d);
CAPNP_DECLARE_SCHEMA(d5d92c1deda3a065);
CAPNP_DECLARE_SCHEMA(e66b6d642cc9952c);
CAPNP_DECLARE_SCHEMA(911e7215e6f25ee0);
CAPNP_DECLARE_SCHEMA(c0e4cff46ab292c3);
CAPNP_DECLARE_SCHEMA(e148f7682011f583);
CAPNP_DECLARE_SCHEMA(99c00f01c04ed08d);
CAPNP_DECLARE_SCHEMA(a5c4c1f880e3ad57);
CAPNP_DECLARE_SCHEMA(88b49e0dd84cbe8f);
CAPNP_DECLARE_SCHEMA(950968b1e5a0dc99);
CAPNP_DECLARE_SCHEMA(e01c02dffc9c1c7e);
CAPNP_DECLARE_SCHEMA(ee3579aca2377415);
CAPNP_DECLARE_SCHEMA(98949bbf1e788a69);
CAPNP_DECLARE_SCHEMA(ca93c8da922da39c);
CAPNP_DECLARE_SCHEMA(eb46205e20eb680f);
CAPNP_DECLARE_SCHEMA(b5ca2345f3c07737);
CAPNP_DECLARE_SCHEMA(fc31b3ae6c8c8585);
CAPNP_DECLARE_SCHEMA(a5df71b5f470d687);

}  // namespace schemas
}  // namespace capnp


struct Term {
  Term() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b522a997799c0d00, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Constraint {
  Constraint() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9c312e7f89b7f157, 0, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct AssignedVariable {
  AssignedVariable() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ace0e474025dc6a2, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct CustomKeyValue {
  CustomKeyValue() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e71a04084cc54a1a, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct StructuredGadgetInterface {
  StructuredGadgetInterface() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    VARIABLES,
    STRUCTS,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8957f59f216dc578, 1, 4)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct GadgetInstance {
  GadgetInstance() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(bea209a4d3b01d5d, 1, 4)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct R1CSRequest {
  R1CSRequest() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d5d92c1deda3a065, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct R1CSChunk {
  R1CSChunk() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e66b6d642cc9952c, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct R1CSResponse {
  R1CSResponse() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(911e7215e6f25ee0, 1, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct AssignmentsRequest {
  AssignmentsRequest() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c0e4cff46ab292c3, 0, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct AssignmentsChunk {
  AssignmentsChunk() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e148f7682011f583, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct AssignmentsResponse {
  AssignmentsResponse() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(99c00f01c04ed08d, 1, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct GadgetRequest {
  GadgetRequest() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    MAKE_R1_C_S,
    MAKE_ASSIGNMENTS,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a5c4c1f880e3ad57, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Parent {
  Parent() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct ConstrainParams;
  struct ConstrainResults;
  struct AssignParams;
  struct AssignResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(88b49e0dd84cbe8f)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct Parent::ConstrainParams {
  ConstrainParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(950968b1e5a0dc99, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Parent::ConstrainResults {
  ConstrainResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e01c02dffc9c1c7e, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Parent::AssignParams {
  AssignParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ee3579aca2377415, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Parent::AssignResults {
  AssignResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(98949bbf1e788a69, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Gadget {
  Gadget() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct MakeR1CSParams;
  struct MakeR1CSResults;
  struct MakeAssignmentsParams;
  struct MakeAssignmentsResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(ca93c8da922da39c)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct Gadget::MakeR1CSParams {
  MakeR1CSParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(eb46205e20eb680f, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Gadget::MakeR1CSResults {
  MakeR1CSResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b5ca2345f3c07737, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Gadget::MakeAssignmentsParams {
  MakeAssignmentsParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(fc31b3ae6c8c8585, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Gadget::MakeAssignmentsResults {
  MakeAssignmentsResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a5df71b5f470d687, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

// =======================================================================================

class Term::Reader {
public:
  typedef Term Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasCoefficient() const;
  inline  ::capnp::Data::Reader getCoefficient() const;

  inline  ::uint64_t getVariableId() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Term::Builder {
public:
  typedef Term Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasCoefficient();
  inline  ::capnp::Data::Builder getCoefficient();
  inline void setCoefficient( ::capnp::Data::Reader value);
  inline  ::capnp::Data::Builder initCoefficient(unsigned int size);
  inline void adoptCoefficient(::capnp::Orphan< ::capnp::Data>&& value);
  inline ::capnp::Orphan< ::capnp::Data> disownCoefficient();

  inline  ::uint64_t getVariableId();
  inline void setVariableId( ::uint64_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Term::Pipeline {
public:
  typedef Term Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Constraint::Reader {
public:
  typedef Constraint Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasA() const;
  inline  ::capnp::List< ::Term,  ::capnp::Kind::STRUCT>::Reader getA() const;

  inline bool hasB() const;
  inline  ::capnp::List< ::Term,  ::capnp::Kind::STRUCT>::Reader getB() const;

  inline bool hasC() const;
  inline  ::capnp::List< ::Term,  ::capnp::Kind::STRUCT>::Reader getC() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Constraint::Builder {
public:
  typedef Constraint Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasA();
  inline  ::capnp::List< ::Term,  ::capnp::Kind::STRUCT>::Builder getA();
  inline void setA( ::capnp::List< ::Term,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::Term,  ::capnp::Kind::STRUCT>::Builder initA(unsigned int size);
  inline void adoptA(::capnp::Orphan< ::capnp::List< ::Term,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::Term,  ::capnp::Kind::STRUCT>> disownA();

  inline bool hasB();
  inline  ::capnp::List< ::Term,  ::capnp::Kind::STRUCT>::Builder getB();
  inline void setB( ::capnp::List< ::Term,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::Term,  ::capnp::Kind::STRUCT>::Builder initB(unsigned int size);
  inline void adoptB(::capnp::Orphan< ::capnp::List< ::Term,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::Term,  ::capnp::Kind::STRUCT>> disownB();

  inline bool hasC();
  inline  ::capnp::List< ::Term,  ::capnp::Kind::STRUCT>::Builder getC();
  inline void setC( ::capnp::List< ::Term,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::Term,  ::capnp::Kind::STRUCT>::Builder initC(unsigned int size);
  inline void adoptC(::capnp::Orphan< ::capnp::List< ::Term,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::Term,  ::capnp::Kind::STRUCT>> disownC();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Constraint::Pipeline {
public:
  typedef Constraint Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class AssignedVariable::Reader {
public:
  typedef AssignedVariable Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasValue() const;
  inline  ::capnp::Data::Reader getValue() const;

  inline  ::uint64_t getVariableId() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class AssignedVariable::Builder {
public:
  typedef AssignedVariable Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasValue();
  inline  ::capnp::Data::Builder getValue();
  inline void setValue( ::capnp::Data::Reader value);
  inline  ::capnp::Data::Builder initValue(unsigned int size);
  inline void adoptValue(::capnp::Orphan< ::capnp::Data>&& value);
  inline ::capnp::Orphan< ::capnp::Data> disownValue();

  inline  ::uint64_t getVariableId();
  inline void setVariableId( ::uint64_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class AssignedVariable::Pipeline {
public:
  typedef AssignedVariable Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class CustomKeyValue::Reader {
public:
  typedef CustomKeyValue Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasKey() const;
  inline  ::capnp::Text::Reader getKey() const;

  inline bool hasValue() const;
  inline  ::capnp::Data::Reader getValue() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class CustomKeyValue::Builder {
public:
  typedef CustomKeyValue Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasKey();
  inline  ::capnp::Text::Builder getKey();
  inline void setKey( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initKey(unsigned int size);
  inline void adoptKey(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownKey();

  inline bool hasValue();
  inline  ::capnp::Data::Builder getValue();
  inline void setValue( ::capnp::Data::Reader value);
  inline  ::capnp::Data::Builder initValue(unsigned int size);
  inline void adoptValue(::capnp::Orphan< ::capnp::Data>&& value);
  inline ::capnp::Orphan< ::capnp::Data> disownValue();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class CustomKeyValue::Pipeline {
public:
  typedef CustomKeyValue Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class StructuredGadgetInterface::Reader {
public:
  typedef StructuredGadgetInterface Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isVariables() const;
  inline bool hasVariables() const;
  inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader getVariables() const;

  inline bool isStructs() const;
  inline bool hasStructs() const;
  inline  ::capnp::List< ::StructuredGadgetInterface,  ::capnp::Kind::STRUCT>::Reader getStructs() const;

  inline bool hasType() const;
  inline  ::capnp::Text::Reader getType() const;

  inline bool hasName() const;
  inline  ::capnp::Text::Reader getName() const;

  inline bool hasInfo() const;
  inline  ::capnp::List< ::CustomKeyValue,  ::capnp::Kind::STRUCT>::Reader getInfo() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class StructuredGadgetInterface::Builder {
public:
  typedef StructuredGadgetInterface Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isVariables();
  inline bool hasVariables();
  inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder getVariables();
  inline void setVariables( ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setVariables(::kj::ArrayPtr<const  ::uint64_t> value);
  inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder initVariables(unsigned int size);
  inline void adoptVariables(::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>> disownVariables();

  inline bool isStructs();
  inline bool hasStructs();
  inline  ::capnp::List< ::StructuredGadgetInterface,  ::capnp::Kind::STRUCT>::Builder getStructs();
  inline void setStructs( ::capnp::List< ::StructuredGadgetInterface,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::StructuredGadgetInterface,  ::capnp::Kind::STRUCT>::Builder initStructs(unsigned int size);
  inline void adoptStructs(::capnp::Orphan< ::capnp::List< ::StructuredGadgetInterface,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::StructuredGadgetInterface,  ::capnp::Kind::STRUCT>> disownStructs();

  inline bool hasType();
  inline  ::capnp::Text::Builder getType();
  inline void setType( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initType(unsigned int size);
  inline void adoptType(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownType();

  inline bool hasName();
  inline  ::capnp::Text::Builder getName();
  inline void setName( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initName(unsigned int size);
  inline void adoptName(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownName();

  inline bool hasInfo();
  inline  ::capnp::List< ::CustomKeyValue,  ::capnp::Kind::STRUCT>::Builder getInfo();
  inline void setInfo( ::capnp::List< ::CustomKeyValue,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::CustomKeyValue,  ::capnp::Kind::STRUCT>::Builder initInfo(unsigned int size);
  inline void adoptInfo(::capnp::Orphan< ::capnp::List< ::CustomKeyValue,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::CustomKeyValue,  ::capnp::Kind::STRUCT>> disownInfo();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class StructuredGadgetInterface::Pipeline {
public:
  typedef StructuredGadgetInterface Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class GadgetInstance::Reader {
public:
  typedef GadgetInstance Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasGadgetName() const;
  inline  ::capnp::Text::Reader getGadgetName() const;

  inline bool hasParameters() const;
  inline  ::capnp::List< ::CustomKeyValue,  ::capnp::Kind::STRUCT>::Reader getParameters() const;

  inline bool hasIncomingStruct() const;
  inline  ::StructuredGadgetInterface::Reader getIncomingStruct() const;

  inline bool hasOutgoingStruct() const;
  inline  ::StructuredGadgetInterface::Reader getOutgoingStruct() const;

  inline  ::uint64_t getFreeVariableId() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class GadgetInstance::Builder {
public:
  typedef GadgetInstance Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasGadgetName();
  inline  ::capnp::Text::Builder getGadgetName();
  inline void setGadgetName( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initGadgetName(unsigned int size);
  inline void adoptGadgetName(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownGadgetName();

  inline bool hasParameters();
  inline  ::capnp::List< ::CustomKeyValue,  ::capnp::Kind::STRUCT>::Builder getParameters();
  inline void setParameters( ::capnp::List< ::CustomKeyValue,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::CustomKeyValue,  ::capnp::Kind::STRUCT>::Builder initParameters(unsigned int size);
  inline void adoptParameters(::capnp::Orphan< ::capnp::List< ::CustomKeyValue,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::CustomKeyValue,  ::capnp::Kind::STRUCT>> disownParameters();

  inline bool hasIncomingStruct();
  inline  ::StructuredGadgetInterface::Builder getIncomingStruct();
  inline void setIncomingStruct( ::StructuredGadgetInterface::Reader value);
  inline  ::StructuredGadgetInterface::Builder initIncomingStruct();
  inline void adoptIncomingStruct(::capnp::Orphan< ::StructuredGadgetInterface>&& value);
  inline ::capnp::Orphan< ::StructuredGadgetInterface> disownIncomingStruct();

  inline bool hasOutgoingStruct();
  inline  ::StructuredGadgetInterface::Builder getOutgoingStruct();
  inline void setOutgoingStruct( ::StructuredGadgetInterface::Reader value);
  inline  ::StructuredGadgetInterface::Builder initOutgoingStruct();
  inline void adoptOutgoingStruct(::capnp::Orphan< ::StructuredGadgetInterface>&& value);
  inline ::capnp::Orphan< ::StructuredGadgetInterface> disownOutgoingStruct();

  inline  ::uint64_t getFreeVariableId();
  inline void setFreeVariableId( ::uint64_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class GadgetInstance::Pipeline {
public:
  typedef GadgetInstance Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::StructuredGadgetInterface::Pipeline getIncomingStruct();
  inline  ::StructuredGadgetInterface::Pipeline getOutgoingStruct();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class R1CSRequest::Reader {
public:
  typedef R1CSRequest Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasInstance() const;
  inline  ::GadgetInstance::Reader getInstance() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class R1CSRequest::Builder {
public:
  typedef R1CSRequest Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasInstance();
  inline  ::GadgetInstance::Builder getInstance();
  inline void setInstance( ::GadgetInstance::Reader value);
  inline  ::GadgetInstance::Builder initInstance();
  inline void adoptInstance(::capnp::Orphan< ::GadgetInstance>&& value);
  inline ::capnp::Orphan< ::GadgetInstance> disownInstance();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class R1CSRequest::Pipeline {
public:
  typedef R1CSRequest Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::GadgetInstance::Pipeline getInstance();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class R1CSChunk::Reader {
public:
  typedef R1CSChunk Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasConstraints() const;
  inline  ::capnp::List< ::Constraint,  ::capnp::Kind::STRUCT>::Reader getConstraints() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class R1CSChunk::Builder {
public:
  typedef R1CSChunk Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasConstraints();
  inline  ::capnp::List< ::Constraint,  ::capnp::Kind::STRUCT>::Builder getConstraints();
  inline void setConstraints( ::capnp::List< ::Constraint,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::Constraint,  ::capnp::Kind::STRUCT>::Builder initConstraints(unsigned int size);
  inline void adoptConstraints(::capnp::Orphan< ::capnp::List< ::Constraint,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::Constraint,  ::capnp::Kind::STRUCT>> disownConstraints();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class R1CSChunk::Pipeline {
public:
  typedef R1CSChunk Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class R1CSResponse::Reader {
public:
  typedef R1CSResponse Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getFreeVariableId() const;

  inline bool hasInfo() const;
  inline  ::capnp::List< ::CustomKeyValue,  ::capnp::Kind::STRUCT>::Reader getInfo() const;

  inline bool hasError() const;
  inline  ::capnp::Text::Reader getError() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class R1CSResponse::Builder {
public:
  typedef R1CSResponse Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getFreeVariableId();
  inline void setFreeVariableId( ::uint64_t value);

  inline bool hasInfo();
  inline  ::capnp::List< ::CustomKeyValue,  ::capnp::Kind::STRUCT>::Builder getInfo();
  inline void setInfo( ::capnp::List< ::CustomKeyValue,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::CustomKeyValue,  ::capnp::Kind::STRUCT>::Builder initInfo(unsigned int size);
  inline void adoptInfo(::capnp::Orphan< ::capnp::List< ::CustomKeyValue,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::CustomKeyValue,  ::capnp::Kind::STRUCT>> disownInfo();

  inline bool hasError();
  inline  ::capnp::Text::Builder getError();
  inline void setError( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initError(unsigned int size);
  inline void adoptError(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownError();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class R1CSResponse::Pipeline {
public:
  typedef R1CSResponse Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class AssignmentsRequest::Reader {
public:
  typedef AssignmentsRequest Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasInstance() const;
  inline  ::GadgetInstance::Reader getInstance() const;

  inline bool hasWitness() const;
  inline  ::capnp::List< ::CustomKeyValue,  ::capnp::Kind::STRUCT>::Reader getWitness() const;

  inline bool hasIncomingAssignments() const;
  inline  ::capnp::List< ::AssignedVariable,  ::capnp::Kind::STRUCT>::Reader getIncomingAssignments() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class AssignmentsRequest::Builder {
public:
  typedef AssignmentsRequest Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasInstance();
  inline  ::GadgetInstance::Builder getInstance();
  inline void setInstance( ::GadgetInstance::Reader value);
  inline  ::GadgetInstance::Builder initInstance();
  inline void adoptInstance(::capnp::Orphan< ::GadgetInstance>&& value);
  inline ::capnp::Orphan< ::GadgetInstance> disownInstance();

  inline bool hasWitness();
  inline  ::capnp::List< ::CustomKeyValue,  ::capnp::Kind::STRUCT>::Builder getWitness();
  inline void setWitness( ::capnp::List< ::CustomKeyValue,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::CustomKeyValue,  ::capnp::Kind::STRUCT>::Builder initWitness(unsigned int size);
  inline void adoptWitness(::capnp::Orphan< ::capnp::List< ::CustomKeyValue,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::CustomKeyValue,  ::capnp::Kind::STRUCT>> disownWitness();

  inline bool hasIncomingAssignments();
  inline  ::capnp::List< ::AssignedVariable,  ::capnp::Kind::STRUCT>::Builder getIncomingAssignments();
  inline void setIncomingAssignments( ::capnp::List< ::AssignedVariable,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::AssignedVariable,  ::capnp::Kind::STRUCT>::Builder initIncomingAssignments(unsigned int size);
  inline void adoptIncomingAssignments(::capnp::Orphan< ::capnp::List< ::AssignedVariable,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::AssignedVariable,  ::capnp::Kind::STRUCT>> disownIncomingAssignments();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class AssignmentsRequest::Pipeline {
public:
  typedef AssignmentsRequest Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::GadgetInstance::Pipeline getInstance();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class AssignmentsChunk::Reader {
public:
  typedef AssignmentsChunk Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasAssignments() const;
  inline  ::capnp::List< ::AssignedVariable,  ::capnp::Kind::STRUCT>::Reader getAssignments() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class AssignmentsChunk::Builder {
public:
  typedef AssignmentsChunk Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasAssignments();
  inline  ::capnp::List< ::AssignedVariable,  ::capnp::Kind::STRUCT>::Builder getAssignments();
  inline void setAssignments( ::capnp::List< ::AssignedVariable,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::AssignedVariable,  ::capnp::Kind::STRUCT>::Builder initAssignments(unsigned int size);
  inline void adoptAssignments(::capnp::Orphan< ::capnp::List< ::AssignedVariable,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::AssignedVariable,  ::capnp::Kind::STRUCT>> disownAssignments();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class AssignmentsChunk::Pipeline {
public:
  typedef AssignmentsChunk Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class AssignmentsResponse::Reader {
public:
  typedef AssignmentsResponse Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getFreeVariableId() const;

  inline bool hasInfo() const;
  inline  ::capnp::List< ::CustomKeyValue,  ::capnp::Kind::STRUCT>::Reader getInfo() const;

  inline bool hasOutgoingAssignments() const;
  inline  ::capnp::List< ::AssignedVariable,  ::capnp::Kind::STRUCT>::Reader getOutgoingAssignments() const;

  inline bool hasError() const;
  inline  ::capnp::Text::Reader getError() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class AssignmentsResponse::Builder {
public:
  typedef AssignmentsResponse Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getFreeVariableId();
  inline void setFreeVariableId( ::uint64_t value);

  inline bool hasInfo();
  inline  ::capnp::List< ::CustomKeyValue,  ::capnp::Kind::STRUCT>::Builder getInfo();
  inline void setInfo( ::capnp::List< ::CustomKeyValue,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::CustomKeyValue,  ::capnp::Kind::STRUCT>::Builder initInfo(unsigned int size);
  inline void adoptInfo(::capnp::Orphan< ::capnp::List< ::CustomKeyValue,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::CustomKeyValue,  ::capnp::Kind::STRUCT>> disownInfo();

  inline bool hasOutgoingAssignments();
  inline  ::capnp::List< ::AssignedVariable,  ::capnp::Kind::STRUCT>::Builder getOutgoingAssignments();
  inline void setOutgoingAssignments( ::capnp::List< ::AssignedVariable,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::AssignedVariable,  ::capnp::Kind::STRUCT>::Builder initOutgoingAssignments(unsigned int size);
  inline void adoptOutgoingAssignments(::capnp::Orphan< ::capnp::List< ::AssignedVariable,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::AssignedVariable,  ::capnp::Kind::STRUCT>> disownOutgoingAssignments();

  inline bool hasError();
  inline  ::capnp::Text::Builder getError();
  inline void setError( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initError(unsigned int size);
  inline void adoptError(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownError();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class AssignmentsResponse::Pipeline {
public:
  typedef AssignmentsResponse Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class GadgetRequest::Reader {
public:
  typedef GadgetRequest Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isMakeR1CS() const;
  inline bool hasMakeR1CS() const;
  inline  ::R1CSRequest::Reader getMakeR1CS() const;

  inline bool isMakeAssignments() const;
  inline bool hasMakeAssignments() const;
  inline  ::AssignmentsRequest::Reader getMakeAssignments() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class GadgetRequest::Builder {
public:
  typedef GadgetRequest Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isMakeR1CS();
  inline bool hasMakeR1CS();
  inline  ::R1CSRequest::Builder getMakeR1CS();
  inline void setMakeR1CS( ::R1CSRequest::Reader value);
  inline  ::R1CSRequest::Builder initMakeR1CS();
  inline void adoptMakeR1CS(::capnp::Orphan< ::R1CSRequest>&& value);
  inline ::capnp::Orphan< ::R1CSRequest> disownMakeR1CS();

  inline bool isMakeAssignments();
  inline bool hasMakeAssignments();
  inline  ::AssignmentsRequest::Builder getMakeAssignments();
  inline void setMakeAssignments( ::AssignmentsRequest::Reader value);
  inline  ::AssignmentsRequest::Builder initMakeAssignments();
  inline void adoptMakeAssignments(::capnp::Orphan< ::AssignmentsRequest>&& value);
  inline ::capnp::Orphan< ::AssignmentsRequest> disownMakeAssignments();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class GadgetRequest::Pipeline {
public:
  typedef GadgetRequest Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class Parent::Client
    : public virtual ::capnp::Capability::Client {
public:
  typedef Parent Calls;
  typedef Parent Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::Parent::ConstrainParams,  ::Parent::ConstrainResults> constrainRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::Parent::AssignParams,  ::Parent::AssignResults> assignRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class Parent::Server
    : public virtual ::capnp::Capability::Server {
public:
  typedef Parent Serves;

  ::kj::Promise<void> dispatchCall(uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::Parent::ConstrainParams ConstrainParams;
  typedef  ::Parent::ConstrainResults ConstrainResults;
  typedef ::capnp::CallContext<ConstrainParams, ConstrainResults> ConstrainContext;
  virtual ::kj::Promise<void> constrain(ConstrainContext context);
  typedef  ::Parent::AssignParams AssignParams;
  typedef  ::Parent::AssignResults AssignResults;
  typedef ::capnp::CallContext<AssignParams, AssignResults> AssignContext;
  virtual ::kj::Promise<void> assign(AssignContext context);

  inline  ::Parent::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::Parent>();
  }

  ::kj::Promise<void> dispatchCallInternal(uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class Parent::ConstrainParams::Reader {
public:
  typedef ConstrainParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasChunk() const;
  inline  ::R1CSChunk::Reader getChunk() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Parent::ConstrainParams::Builder {
public:
  typedef ConstrainParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasChunk();
  inline  ::R1CSChunk::Builder getChunk();
  inline void setChunk( ::R1CSChunk::Reader value);
  inline  ::R1CSChunk::Builder initChunk();
  inline void adoptChunk(::capnp::Orphan< ::R1CSChunk>&& value);
  inline ::capnp::Orphan< ::R1CSChunk> disownChunk();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Parent::ConstrainParams::Pipeline {
public:
  typedef ConstrainParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::R1CSChunk::Pipeline getChunk();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Parent::ConstrainResults::Reader {
public:
  typedef ConstrainResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool getOk() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Parent::ConstrainResults::Builder {
public:
  typedef ConstrainResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool getOk();
  inline void setOk(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Parent::ConstrainResults::Pipeline {
public:
  typedef ConstrainResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Parent::AssignParams::Reader {
public:
  typedef AssignParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasChunk() const;
  inline  ::AssignmentsChunk::Reader getChunk() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Parent::AssignParams::Builder {
public:
  typedef AssignParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasChunk();
  inline  ::AssignmentsChunk::Builder getChunk();
  inline void setChunk( ::AssignmentsChunk::Reader value);
  inline  ::AssignmentsChunk::Builder initChunk();
  inline void adoptChunk(::capnp::Orphan< ::AssignmentsChunk>&& value);
  inline ::capnp::Orphan< ::AssignmentsChunk> disownChunk();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Parent::AssignParams::Pipeline {
public:
  typedef AssignParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::AssignmentsChunk::Pipeline getChunk();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Parent::AssignResults::Reader {
public:
  typedef AssignResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool getOk() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Parent::AssignResults::Builder {
public:
  typedef AssignResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool getOk();
  inline void setOk(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Parent::AssignResults::Pipeline {
public:
  typedef AssignResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class Gadget::Client
    : public virtual ::capnp::Capability::Client {
public:
  typedef Gadget Calls;
  typedef Gadget Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::Gadget::MakeR1CSParams,  ::Gadget::MakeR1CSResults> makeR1CSRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::Gadget::MakeAssignmentsParams,  ::Gadget::MakeAssignmentsResults> makeAssignmentsRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class Gadget::Server
    : public virtual ::capnp::Capability::Server {
public:
  typedef Gadget Serves;

  ::kj::Promise<void> dispatchCall(uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::Gadget::MakeR1CSParams MakeR1CSParams;
  typedef  ::Gadget::MakeR1CSResults MakeR1CSResults;
  typedef ::capnp::CallContext<MakeR1CSParams, MakeR1CSResults> MakeR1CSContext;
  virtual ::kj::Promise<void> makeR1CS(MakeR1CSContext context);
  typedef  ::Gadget::MakeAssignmentsParams MakeAssignmentsParams;
  typedef  ::Gadget::MakeAssignmentsResults MakeAssignmentsResults;
  typedef ::capnp::CallContext<MakeAssignmentsParams, MakeAssignmentsResults> MakeAssignmentsContext;
  virtual ::kj::Promise<void> makeAssignments(MakeAssignmentsContext context);

  inline  ::Gadget::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::Gadget>();
  }

  ::kj::Promise<void> dispatchCallInternal(uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class Gadget::MakeR1CSParams::Reader {
public:
  typedef MakeR1CSParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasParams() const;
  inline  ::R1CSRequest::Reader getParams() const;

  inline bool hasCaller() const;
#if !CAPNP_LITE
  inline  ::Parent::Client getCaller() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Gadget::MakeR1CSParams::Builder {
public:
  typedef MakeR1CSParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasParams();
  inline  ::R1CSRequest::Builder getParams();
  inline void setParams( ::R1CSRequest::Reader value);
  inline  ::R1CSRequest::Builder initParams();
  inline void adoptParams(::capnp::Orphan< ::R1CSRequest>&& value);
  inline ::capnp::Orphan< ::R1CSRequest> disownParams();

  inline bool hasCaller();
#if !CAPNP_LITE
  inline  ::Parent::Client getCaller();
  inline void setCaller( ::Parent::Client&& value);
  inline void setCaller( ::Parent::Client& value);
  inline void adoptCaller(::capnp::Orphan< ::Parent>&& value);
  inline ::capnp::Orphan< ::Parent> disownCaller();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Gadget::MakeR1CSParams::Pipeline {
public:
  typedef MakeR1CSParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::R1CSRequest::Pipeline getParams();
  inline  ::Parent::Client getCaller();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Gadget::MakeR1CSResults::Reader {
public:
  typedef MakeR1CSResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasRes() const;
  inline  ::R1CSResponse::Reader getRes() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Gadget::MakeR1CSResults::Builder {
public:
  typedef MakeR1CSResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasRes();
  inline  ::R1CSResponse::Builder getRes();
  inline void setRes( ::R1CSResponse::Reader value);
  inline  ::R1CSResponse::Builder initRes();
  inline void adoptRes(::capnp::Orphan< ::R1CSResponse>&& value);
  inline ::capnp::Orphan< ::R1CSResponse> disownRes();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Gadget::MakeR1CSResults::Pipeline {
public:
  typedef MakeR1CSResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::R1CSResponse::Pipeline getRes();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Gadget::MakeAssignmentsParams::Reader {
public:
  typedef MakeAssignmentsParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasParams() const;
  inline  ::AssignmentsRequest::Reader getParams() const;

  inline bool hasCaller() const;
#if !CAPNP_LITE
  inline  ::Parent::Client getCaller() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Gadget::MakeAssignmentsParams::Builder {
public:
  typedef MakeAssignmentsParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasParams();
  inline  ::AssignmentsRequest::Builder getParams();
  inline void setParams( ::AssignmentsRequest::Reader value);
  inline  ::AssignmentsRequest::Builder initParams();
  inline void adoptParams(::capnp::Orphan< ::AssignmentsRequest>&& value);
  inline ::capnp::Orphan< ::AssignmentsRequest> disownParams();

  inline bool hasCaller();
#if !CAPNP_LITE
  inline  ::Parent::Client getCaller();
  inline void setCaller( ::Parent::Client&& value);
  inline void setCaller( ::Parent::Client& value);
  inline void adoptCaller(::capnp::Orphan< ::Parent>&& value);
  inline ::capnp::Orphan< ::Parent> disownCaller();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Gadget::MakeAssignmentsParams::Pipeline {
public:
  typedef MakeAssignmentsParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::AssignmentsRequest::Pipeline getParams();
  inline  ::Parent::Client getCaller();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Gadget::MakeAssignmentsResults::Reader {
public:
  typedef MakeAssignmentsResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasRes() const;
  inline  ::AssignmentsResponse::Reader getRes() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Gadget::MakeAssignmentsResults::Builder {
public:
  typedef MakeAssignmentsResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasRes();
  inline  ::AssignmentsResponse::Builder getRes();
  inline void setRes( ::AssignmentsResponse::Reader value);
  inline  ::AssignmentsResponse::Builder initRes();
  inline void adoptRes(::capnp::Orphan< ::AssignmentsResponse>&& value);
  inline ::capnp::Orphan< ::AssignmentsResponse> disownRes();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Gadget::MakeAssignmentsResults::Pipeline {
public:
  typedef MakeAssignmentsResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::AssignmentsResponse::Pipeline getRes();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

// =======================================================================================

inline bool Term::Reader::hasCoefficient() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Term::Builder::hasCoefficient() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Data::Reader Term::Reader::getCoefficient() const {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Data::Builder Term::Builder::getCoefficient() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Term::Builder::setCoefficient( ::capnp::Data::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Data::Builder Term::Builder::initCoefficient(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Term::Builder::adoptCoefficient(
    ::capnp::Orphan< ::capnp::Data>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Data> Term::Builder::disownCoefficient() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint64_t Term::Reader::getVariableId() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t Term::Builder::getVariableId() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Term::Builder::setVariableId( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Constraint::Reader::hasA() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Constraint::Builder::hasA() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::Term,  ::capnp::Kind::STRUCT>::Reader Constraint::Reader::getA() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Term,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::Term,  ::capnp::Kind::STRUCT>::Builder Constraint::Builder::getA() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Term,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Constraint::Builder::setA( ::capnp::List< ::Term,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Term,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::Term,  ::capnp::Kind::STRUCT>::Builder Constraint::Builder::initA(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Term,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Constraint::Builder::adoptA(
    ::capnp::Orphan< ::capnp::List< ::Term,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Term,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::Term,  ::capnp::Kind::STRUCT>> Constraint::Builder::disownA() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Term,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Constraint::Reader::hasB() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Constraint::Builder::hasB() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::Term,  ::capnp::Kind::STRUCT>::Reader Constraint::Reader::getB() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Term,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::Term,  ::capnp::Kind::STRUCT>::Builder Constraint::Builder::getB() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Term,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Constraint::Builder::setB( ::capnp::List< ::Term,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Term,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::Term,  ::capnp::Kind::STRUCT>::Builder Constraint::Builder::initB(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Term,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void Constraint::Builder::adoptB(
    ::capnp::Orphan< ::capnp::List< ::Term,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Term,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::Term,  ::capnp::Kind::STRUCT>> Constraint::Builder::disownB() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Term,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Constraint::Reader::hasC() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool Constraint::Builder::hasC() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::Term,  ::capnp::Kind::STRUCT>::Reader Constraint::Reader::getC() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Term,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::Term,  ::capnp::Kind::STRUCT>::Builder Constraint::Builder::getC() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Term,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void Constraint::Builder::setC( ::capnp::List< ::Term,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Term,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::Term,  ::capnp::Kind::STRUCT>::Builder Constraint::Builder::initC(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Term,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), size);
}
inline void Constraint::Builder::adoptC(
    ::capnp::Orphan< ::capnp::List< ::Term,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Term,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::Term,  ::capnp::Kind::STRUCT>> Constraint::Builder::disownC() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Term,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool AssignedVariable::Reader::hasValue() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool AssignedVariable::Builder::hasValue() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Data::Reader AssignedVariable::Reader::getValue() const {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Data::Builder AssignedVariable::Builder::getValue() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void AssignedVariable::Builder::setValue( ::capnp::Data::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Data::Builder AssignedVariable::Builder::initValue(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void AssignedVariable::Builder::adoptValue(
    ::capnp::Orphan< ::capnp::Data>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Data> AssignedVariable::Builder::disownValue() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint64_t AssignedVariable::Reader::getVariableId() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t AssignedVariable::Builder::getVariableId() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void AssignedVariable::Builder::setVariableId( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool CustomKeyValue::Reader::hasKey() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool CustomKeyValue::Builder::hasKey() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader CustomKeyValue::Reader::getKey() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder CustomKeyValue::Builder::getKey() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void CustomKeyValue::Builder::setKey( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder CustomKeyValue::Builder::initKey(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void CustomKeyValue::Builder::adoptKey(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> CustomKeyValue::Builder::disownKey() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool CustomKeyValue::Reader::hasValue() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool CustomKeyValue::Builder::hasValue() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Data::Reader CustomKeyValue::Reader::getValue() const {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::Data::Builder CustomKeyValue::Builder::getValue() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void CustomKeyValue::Builder::setValue( ::capnp::Data::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Data::Builder CustomKeyValue::Builder::initValue(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void CustomKeyValue::Builder::adoptValue(
    ::capnp::Orphan< ::capnp::Data>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Data> CustomKeyValue::Builder::disownValue() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline  ::StructuredGadgetInterface::Which StructuredGadgetInterface::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline  ::StructuredGadgetInterface::Which StructuredGadgetInterface::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool StructuredGadgetInterface::Reader::isVariables() const {
  return which() == StructuredGadgetInterface::VARIABLES;
}
inline bool StructuredGadgetInterface::Builder::isVariables() {
  return which() == StructuredGadgetInterface::VARIABLES;
}
inline bool StructuredGadgetInterface::Reader::hasVariables() const {
  if (which() != StructuredGadgetInterface::VARIABLES) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool StructuredGadgetInterface::Builder::hasVariables() {
  if (which() != StructuredGadgetInterface::VARIABLES) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader StructuredGadgetInterface::Reader::getVariables() const {
  KJ_IREQUIRE((which() == StructuredGadgetInterface::VARIABLES),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder StructuredGadgetInterface::Builder::getVariables() {
  KJ_IREQUIRE((which() == StructuredGadgetInterface::VARIABLES),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void StructuredGadgetInterface::Builder::setVariables( ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  _builder.setDataField<StructuredGadgetInterface::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, StructuredGadgetInterface::VARIABLES);
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline void StructuredGadgetInterface::Builder::setVariables(::kj::ArrayPtr<const  ::uint64_t> value) {
  _builder.setDataField<StructuredGadgetInterface::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, StructuredGadgetInterface::VARIABLES);
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>::Builder StructuredGadgetInterface::Builder::initVariables(unsigned int size) {
  _builder.setDataField<StructuredGadgetInterface::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, StructuredGadgetInterface::VARIABLES);
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void StructuredGadgetInterface::Builder::adoptVariables(
    ::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>&& value) {
  _builder.setDataField<StructuredGadgetInterface::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, StructuredGadgetInterface::VARIABLES);
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>> StructuredGadgetInterface::Builder::disownVariables() {
  KJ_IREQUIRE((which() == StructuredGadgetInterface::VARIABLES),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint64_t,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool StructuredGadgetInterface::Reader::isStructs() const {
  return which() == StructuredGadgetInterface::STRUCTS;
}
inline bool StructuredGadgetInterface::Builder::isStructs() {
  return which() == StructuredGadgetInterface::STRUCTS;
}
inline bool StructuredGadgetInterface::Reader::hasStructs() const {
  if (which() != StructuredGadgetInterface::STRUCTS) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool StructuredGadgetInterface::Builder::hasStructs() {
  if (which() != StructuredGadgetInterface::STRUCTS) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::StructuredGadgetInterface,  ::capnp::Kind::STRUCT>::Reader StructuredGadgetInterface::Reader::getStructs() const {
  KJ_IREQUIRE((which() == StructuredGadgetInterface::STRUCTS),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::StructuredGadgetInterface,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::StructuredGadgetInterface,  ::capnp::Kind::STRUCT>::Builder StructuredGadgetInterface::Builder::getStructs() {
  KJ_IREQUIRE((which() == StructuredGadgetInterface::STRUCTS),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::StructuredGadgetInterface,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void StructuredGadgetInterface::Builder::setStructs( ::capnp::List< ::StructuredGadgetInterface,  ::capnp::Kind::STRUCT>::Reader value) {
  _builder.setDataField<StructuredGadgetInterface::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, StructuredGadgetInterface::STRUCTS);
  ::capnp::_::PointerHelpers< ::capnp::List< ::StructuredGadgetInterface,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::StructuredGadgetInterface,  ::capnp::Kind::STRUCT>::Builder StructuredGadgetInterface::Builder::initStructs(unsigned int size) {
  _builder.setDataField<StructuredGadgetInterface::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, StructuredGadgetInterface::STRUCTS);
  return ::capnp::_::PointerHelpers< ::capnp::List< ::StructuredGadgetInterface,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void StructuredGadgetInterface::Builder::adoptStructs(
    ::capnp::Orphan< ::capnp::List< ::StructuredGadgetInterface,  ::capnp::Kind::STRUCT>>&& value) {
  _builder.setDataField<StructuredGadgetInterface::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, StructuredGadgetInterface::STRUCTS);
  ::capnp::_::PointerHelpers< ::capnp::List< ::StructuredGadgetInterface,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::StructuredGadgetInterface,  ::capnp::Kind::STRUCT>> StructuredGadgetInterface::Builder::disownStructs() {
  KJ_IREQUIRE((which() == StructuredGadgetInterface::STRUCTS),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::StructuredGadgetInterface,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool StructuredGadgetInterface::Reader::hasType() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool StructuredGadgetInterface::Builder::hasType() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader StructuredGadgetInterface::Reader::getType() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder StructuredGadgetInterface::Builder::getType() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void StructuredGadgetInterface::Builder::setType( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder StructuredGadgetInterface::Builder::initType(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void StructuredGadgetInterface::Builder::adoptType(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> StructuredGadgetInterface::Builder::disownType() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool StructuredGadgetInterface::Reader::hasName() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool StructuredGadgetInterface::Builder::hasName() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader StructuredGadgetInterface::Reader::getName() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder StructuredGadgetInterface::Builder::getName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void StructuredGadgetInterface::Builder::setName( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder StructuredGadgetInterface::Builder::initName(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), size);
}
inline void StructuredGadgetInterface::Builder::adoptName(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> StructuredGadgetInterface::Builder::disownName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool StructuredGadgetInterface::Reader::hasInfo() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool StructuredGadgetInterface::Builder::hasInfo() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::CustomKeyValue,  ::capnp::Kind::STRUCT>::Reader StructuredGadgetInterface::Reader::getInfo() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::CustomKeyValue,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::CustomKeyValue,  ::capnp::Kind::STRUCT>::Builder StructuredGadgetInterface::Builder::getInfo() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::CustomKeyValue,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void StructuredGadgetInterface::Builder::setInfo( ::capnp::List< ::CustomKeyValue,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::CustomKeyValue,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::CustomKeyValue,  ::capnp::Kind::STRUCT>::Builder StructuredGadgetInterface::Builder::initInfo(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::CustomKeyValue,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), size);
}
inline void StructuredGadgetInterface::Builder::adoptInfo(
    ::capnp::Orphan< ::capnp::List< ::CustomKeyValue,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::CustomKeyValue,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::CustomKeyValue,  ::capnp::Kind::STRUCT>> StructuredGadgetInterface::Builder::disownInfo() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::CustomKeyValue,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline bool GadgetInstance::Reader::hasGadgetName() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool GadgetInstance::Builder::hasGadgetName() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader GadgetInstance::Reader::getGadgetName() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder GadgetInstance::Builder::getGadgetName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void GadgetInstance::Builder::setGadgetName( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder GadgetInstance::Builder::initGadgetName(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void GadgetInstance::Builder::adoptGadgetName(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> GadgetInstance::Builder::disownGadgetName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool GadgetInstance::Reader::hasParameters() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool GadgetInstance::Builder::hasParameters() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::CustomKeyValue,  ::capnp::Kind::STRUCT>::Reader GadgetInstance::Reader::getParameters() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::CustomKeyValue,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::CustomKeyValue,  ::capnp::Kind::STRUCT>::Builder GadgetInstance::Builder::getParameters() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::CustomKeyValue,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void GadgetInstance::Builder::setParameters( ::capnp::List< ::CustomKeyValue,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::CustomKeyValue,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::CustomKeyValue,  ::capnp::Kind::STRUCT>::Builder GadgetInstance::Builder::initParameters(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::CustomKeyValue,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void GadgetInstance::Builder::adoptParameters(
    ::capnp::Orphan< ::capnp::List< ::CustomKeyValue,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::CustomKeyValue,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::CustomKeyValue,  ::capnp::Kind::STRUCT>> GadgetInstance::Builder::disownParameters() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::CustomKeyValue,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool GadgetInstance::Reader::hasIncomingStruct() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool GadgetInstance::Builder::hasIncomingStruct() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::StructuredGadgetInterface::Reader GadgetInstance::Reader::getIncomingStruct() const {
  return ::capnp::_::PointerHelpers< ::StructuredGadgetInterface>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::StructuredGadgetInterface::Builder GadgetInstance::Builder::getIncomingStruct() {
  return ::capnp::_::PointerHelpers< ::StructuredGadgetInterface>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::StructuredGadgetInterface::Pipeline GadgetInstance::Pipeline::getIncomingStruct() {
  return  ::StructuredGadgetInterface::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void GadgetInstance::Builder::setIncomingStruct( ::StructuredGadgetInterface::Reader value) {
  ::capnp::_::PointerHelpers< ::StructuredGadgetInterface>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::StructuredGadgetInterface::Builder GadgetInstance::Builder::initIncomingStruct() {
  return ::capnp::_::PointerHelpers< ::StructuredGadgetInterface>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void GadgetInstance::Builder::adoptIncomingStruct(
    ::capnp::Orphan< ::StructuredGadgetInterface>&& value) {
  ::capnp::_::PointerHelpers< ::StructuredGadgetInterface>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::StructuredGadgetInterface> GadgetInstance::Builder::disownIncomingStruct() {
  return ::capnp::_::PointerHelpers< ::StructuredGadgetInterface>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool GadgetInstance::Reader::hasOutgoingStruct() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool GadgetInstance::Builder::hasOutgoingStruct() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::StructuredGadgetInterface::Reader GadgetInstance::Reader::getOutgoingStruct() const {
  return ::capnp::_::PointerHelpers< ::StructuredGadgetInterface>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::StructuredGadgetInterface::Builder GadgetInstance::Builder::getOutgoingStruct() {
  return ::capnp::_::PointerHelpers< ::StructuredGadgetInterface>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::StructuredGadgetInterface::Pipeline GadgetInstance::Pipeline::getOutgoingStruct() {
  return  ::StructuredGadgetInterface::Pipeline(_typeless.getPointerField(3));
}
#endif  // !CAPNP_LITE
inline void GadgetInstance::Builder::setOutgoingStruct( ::StructuredGadgetInterface::Reader value) {
  ::capnp::_::PointerHelpers< ::StructuredGadgetInterface>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::StructuredGadgetInterface::Builder GadgetInstance::Builder::initOutgoingStruct() {
  return ::capnp::_::PointerHelpers< ::StructuredGadgetInterface>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void GadgetInstance::Builder::adoptOutgoingStruct(
    ::capnp::Orphan< ::StructuredGadgetInterface>&& value) {
  ::capnp::_::PointerHelpers< ::StructuredGadgetInterface>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::StructuredGadgetInterface> GadgetInstance::Builder::disownOutgoingStruct() {
  return ::capnp::_::PointerHelpers< ::StructuredGadgetInterface>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline  ::uint64_t GadgetInstance::Reader::getFreeVariableId() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t GadgetInstance::Builder::getFreeVariableId() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void GadgetInstance::Builder::setFreeVariableId( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool R1CSRequest::Reader::hasInstance() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool R1CSRequest::Builder::hasInstance() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::GadgetInstance::Reader R1CSRequest::Reader::getInstance() const {
  return ::capnp::_::PointerHelpers< ::GadgetInstance>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::GadgetInstance::Builder R1CSRequest::Builder::getInstance() {
  return ::capnp::_::PointerHelpers< ::GadgetInstance>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::GadgetInstance::Pipeline R1CSRequest::Pipeline::getInstance() {
  return  ::GadgetInstance::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void R1CSRequest::Builder::setInstance( ::GadgetInstance::Reader value) {
  ::capnp::_::PointerHelpers< ::GadgetInstance>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::GadgetInstance::Builder R1CSRequest::Builder::initInstance() {
  return ::capnp::_::PointerHelpers< ::GadgetInstance>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void R1CSRequest::Builder::adoptInstance(
    ::capnp::Orphan< ::GadgetInstance>&& value) {
  ::capnp::_::PointerHelpers< ::GadgetInstance>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::GadgetInstance> R1CSRequest::Builder::disownInstance() {
  return ::capnp::_::PointerHelpers< ::GadgetInstance>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool R1CSChunk::Reader::hasConstraints() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool R1CSChunk::Builder::hasConstraints() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::Constraint,  ::capnp::Kind::STRUCT>::Reader R1CSChunk::Reader::getConstraints() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Constraint,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::Constraint,  ::capnp::Kind::STRUCT>::Builder R1CSChunk::Builder::getConstraints() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Constraint,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void R1CSChunk::Builder::setConstraints( ::capnp::List< ::Constraint,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Constraint,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::Constraint,  ::capnp::Kind::STRUCT>::Builder R1CSChunk::Builder::initConstraints(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Constraint,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void R1CSChunk::Builder::adoptConstraints(
    ::capnp::Orphan< ::capnp::List< ::Constraint,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Constraint,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::Constraint,  ::capnp::Kind::STRUCT>> R1CSChunk::Builder::disownConstraints() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Constraint,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint64_t R1CSResponse::Reader::getFreeVariableId() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t R1CSResponse::Builder::getFreeVariableId() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void R1CSResponse::Builder::setFreeVariableId( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool R1CSResponse::Reader::hasInfo() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool R1CSResponse::Builder::hasInfo() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::CustomKeyValue,  ::capnp::Kind::STRUCT>::Reader R1CSResponse::Reader::getInfo() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::CustomKeyValue,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::CustomKeyValue,  ::capnp::Kind::STRUCT>::Builder R1CSResponse::Builder::getInfo() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::CustomKeyValue,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void R1CSResponse::Builder::setInfo( ::capnp::List< ::CustomKeyValue,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::CustomKeyValue,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::CustomKeyValue,  ::capnp::Kind::STRUCT>::Builder R1CSResponse::Builder::initInfo(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::CustomKeyValue,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void R1CSResponse::Builder::adoptInfo(
    ::capnp::Orphan< ::capnp::List< ::CustomKeyValue,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::CustomKeyValue,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::CustomKeyValue,  ::capnp::Kind::STRUCT>> R1CSResponse::Builder::disownInfo() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::CustomKeyValue,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool R1CSResponse::Reader::hasError() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool R1CSResponse::Builder::hasError() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader R1CSResponse::Reader::getError() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder R1CSResponse::Builder::getError() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void R1CSResponse::Builder::setError( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder R1CSResponse::Builder::initError(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void R1CSResponse::Builder::adoptError(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> R1CSResponse::Builder::disownError() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool AssignmentsRequest::Reader::hasInstance() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool AssignmentsRequest::Builder::hasInstance() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::GadgetInstance::Reader AssignmentsRequest::Reader::getInstance() const {
  return ::capnp::_::PointerHelpers< ::GadgetInstance>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::GadgetInstance::Builder AssignmentsRequest::Builder::getInstance() {
  return ::capnp::_::PointerHelpers< ::GadgetInstance>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::GadgetInstance::Pipeline AssignmentsRequest::Pipeline::getInstance() {
  return  ::GadgetInstance::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void AssignmentsRequest::Builder::setInstance( ::GadgetInstance::Reader value) {
  ::capnp::_::PointerHelpers< ::GadgetInstance>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::GadgetInstance::Builder AssignmentsRequest::Builder::initInstance() {
  return ::capnp::_::PointerHelpers< ::GadgetInstance>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void AssignmentsRequest::Builder::adoptInstance(
    ::capnp::Orphan< ::GadgetInstance>&& value) {
  ::capnp::_::PointerHelpers< ::GadgetInstance>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::GadgetInstance> AssignmentsRequest::Builder::disownInstance() {
  return ::capnp::_::PointerHelpers< ::GadgetInstance>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool AssignmentsRequest::Reader::hasWitness() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool AssignmentsRequest::Builder::hasWitness() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::CustomKeyValue,  ::capnp::Kind::STRUCT>::Reader AssignmentsRequest::Reader::getWitness() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::CustomKeyValue,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::CustomKeyValue,  ::capnp::Kind::STRUCT>::Builder AssignmentsRequest::Builder::getWitness() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::CustomKeyValue,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void AssignmentsRequest::Builder::setWitness( ::capnp::List< ::CustomKeyValue,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::CustomKeyValue,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::CustomKeyValue,  ::capnp::Kind::STRUCT>::Builder AssignmentsRequest::Builder::initWitness(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::CustomKeyValue,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void AssignmentsRequest::Builder::adoptWitness(
    ::capnp::Orphan< ::capnp::List< ::CustomKeyValue,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::CustomKeyValue,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::CustomKeyValue,  ::capnp::Kind::STRUCT>> AssignmentsRequest::Builder::disownWitness() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::CustomKeyValue,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool AssignmentsRequest::Reader::hasIncomingAssignments() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool AssignmentsRequest::Builder::hasIncomingAssignments() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::AssignedVariable,  ::capnp::Kind::STRUCT>::Reader AssignmentsRequest::Reader::getIncomingAssignments() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::AssignedVariable,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::AssignedVariable,  ::capnp::Kind::STRUCT>::Builder AssignmentsRequest::Builder::getIncomingAssignments() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::AssignedVariable,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void AssignmentsRequest::Builder::setIncomingAssignments( ::capnp::List< ::AssignedVariable,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::AssignedVariable,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::AssignedVariable,  ::capnp::Kind::STRUCT>::Builder AssignmentsRequest::Builder::initIncomingAssignments(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::AssignedVariable,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), size);
}
inline void AssignmentsRequest::Builder::adoptIncomingAssignments(
    ::capnp::Orphan< ::capnp::List< ::AssignedVariable,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::AssignedVariable,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::AssignedVariable,  ::capnp::Kind::STRUCT>> AssignmentsRequest::Builder::disownIncomingAssignments() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::AssignedVariable,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool AssignmentsChunk::Reader::hasAssignments() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool AssignmentsChunk::Builder::hasAssignments() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::AssignedVariable,  ::capnp::Kind::STRUCT>::Reader AssignmentsChunk::Reader::getAssignments() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::AssignedVariable,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::AssignedVariable,  ::capnp::Kind::STRUCT>::Builder AssignmentsChunk::Builder::getAssignments() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::AssignedVariable,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void AssignmentsChunk::Builder::setAssignments( ::capnp::List< ::AssignedVariable,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::AssignedVariable,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::AssignedVariable,  ::capnp::Kind::STRUCT>::Builder AssignmentsChunk::Builder::initAssignments(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::AssignedVariable,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void AssignmentsChunk::Builder::adoptAssignments(
    ::capnp::Orphan< ::capnp::List< ::AssignedVariable,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::AssignedVariable,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::AssignedVariable,  ::capnp::Kind::STRUCT>> AssignmentsChunk::Builder::disownAssignments() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::AssignedVariable,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint64_t AssignmentsResponse::Reader::getFreeVariableId() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t AssignmentsResponse::Builder::getFreeVariableId() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void AssignmentsResponse::Builder::setFreeVariableId( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool AssignmentsResponse::Reader::hasInfo() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool AssignmentsResponse::Builder::hasInfo() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::CustomKeyValue,  ::capnp::Kind::STRUCT>::Reader AssignmentsResponse::Reader::getInfo() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::CustomKeyValue,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::CustomKeyValue,  ::capnp::Kind::STRUCT>::Builder AssignmentsResponse::Builder::getInfo() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::CustomKeyValue,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void AssignmentsResponse::Builder::setInfo( ::capnp::List< ::CustomKeyValue,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::CustomKeyValue,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::CustomKeyValue,  ::capnp::Kind::STRUCT>::Builder AssignmentsResponse::Builder::initInfo(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::CustomKeyValue,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void AssignmentsResponse::Builder::adoptInfo(
    ::capnp::Orphan< ::capnp::List< ::CustomKeyValue,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::CustomKeyValue,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::CustomKeyValue,  ::capnp::Kind::STRUCT>> AssignmentsResponse::Builder::disownInfo() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::CustomKeyValue,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool AssignmentsResponse::Reader::hasOutgoingAssignments() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool AssignmentsResponse::Builder::hasOutgoingAssignments() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::AssignedVariable,  ::capnp::Kind::STRUCT>::Reader AssignmentsResponse::Reader::getOutgoingAssignments() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::AssignedVariable,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::AssignedVariable,  ::capnp::Kind::STRUCT>::Builder AssignmentsResponse::Builder::getOutgoingAssignments() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::AssignedVariable,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void AssignmentsResponse::Builder::setOutgoingAssignments( ::capnp::List< ::AssignedVariable,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::AssignedVariable,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::AssignedVariable,  ::capnp::Kind::STRUCT>::Builder AssignmentsResponse::Builder::initOutgoingAssignments(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::AssignedVariable,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void AssignmentsResponse::Builder::adoptOutgoingAssignments(
    ::capnp::Orphan< ::capnp::List< ::AssignedVariable,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::AssignedVariable,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::AssignedVariable,  ::capnp::Kind::STRUCT>> AssignmentsResponse::Builder::disownOutgoingAssignments() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::AssignedVariable,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool AssignmentsResponse::Reader::hasError() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool AssignmentsResponse::Builder::hasError() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader AssignmentsResponse::Reader::getError() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder AssignmentsResponse::Builder::getError() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void AssignmentsResponse::Builder::setError( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder AssignmentsResponse::Builder::initError(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), size);
}
inline void AssignmentsResponse::Builder::adoptError(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> AssignmentsResponse::Builder::disownError() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline  ::GadgetRequest::Which GadgetRequest::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline  ::GadgetRequest::Which GadgetRequest::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool GadgetRequest::Reader::isMakeR1CS() const {
  return which() == GadgetRequest::MAKE_R1_C_S;
}
inline bool GadgetRequest::Builder::isMakeR1CS() {
  return which() == GadgetRequest::MAKE_R1_C_S;
}
inline bool GadgetRequest::Reader::hasMakeR1CS() const {
  if (which() != GadgetRequest::MAKE_R1_C_S) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool GadgetRequest::Builder::hasMakeR1CS() {
  if (which() != GadgetRequest::MAKE_R1_C_S) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::R1CSRequest::Reader GadgetRequest::Reader::getMakeR1CS() const {
  KJ_IREQUIRE((which() == GadgetRequest::MAKE_R1_C_S),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::R1CSRequest>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::R1CSRequest::Builder GadgetRequest::Builder::getMakeR1CS() {
  KJ_IREQUIRE((which() == GadgetRequest::MAKE_R1_C_S),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::R1CSRequest>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void GadgetRequest::Builder::setMakeR1CS( ::R1CSRequest::Reader value) {
  _builder.setDataField<GadgetRequest::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, GadgetRequest::MAKE_R1_C_S);
  ::capnp::_::PointerHelpers< ::R1CSRequest>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::R1CSRequest::Builder GadgetRequest::Builder::initMakeR1CS() {
  _builder.setDataField<GadgetRequest::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, GadgetRequest::MAKE_R1_C_S);
  return ::capnp::_::PointerHelpers< ::R1CSRequest>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void GadgetRequest::Builder::adoptMakeR1CS(
    ::capnp::Orphan< ::R1CSRequest>&& value) {
  _builder.setDataField<GadgetRequest::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, GadgetRequest::MAKE_R1_C_S);
  ::capnp::_::PointerHelpers< ::R1CSRequest>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::R1CSRequest> GadgetRequest::Builder::disownMakeR1CS() {
  KJ_IREQUIRE((which() == GadgetRequest::MAKE_R1_C_S),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::R1CSRequest>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool GadgetRequest::Reader::isMakeAssignments() const {
  return which() == GadgetRequest::MAKE_ASSIGNMENTS;
}
inline bool GadgetRequest::Builder::isMakeAssignments() {
  return which() == GadgetRequest::MAKE_ASSIGNMENTS;
}
inline bool GadgetRequest::Reader::hasMakeAssignments() const {
  if (which() != GadgetRequest::MAKE_ASSIGNMENTS) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool GadgetRequest::Builder::hasMakeAssignments() {
  if (which() != GadgetRequest::MAKE_ASSIGNMENTS) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::AssignmentsRequest::Reader GadgetRequest::Reader::getMakeAssignments() const {
  KJ_IREQUIRE((which() == GadgetRequest::MAKE_ASSIGNMENTS),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::AssignmentsRequest>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::AssignmentsRequest::Builder GadgetRequest::Builder::getMakeAssignments() {
  KJ_IREQUIRE((which() == GadgetRequest::MAKE_ASSIGNMENTS),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::AssignmentsRequest>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void GadgetRequest::Builder::setMakeAssignments( ::AssignmentsRequest::Reader value) {
  _builder.setDataField<GadgetRequest::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, GadgetRequest::MAKE_ASSIGNMENTS);
  ::capnp::_::PointerHelpers< ::AssignmentsRequest>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::AssignmentsRequest::Builder GadgetRequest::Builder::initMakeAssignments() {
  _builder.setDataField<GadgetRequest::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, GadgetRequest::MAKE_ASSIGNMENTS);
  return ::capnp::_::PointerHelpers< ::AssignmentsRequest>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void GadgetRequest::Builder::adoptMakeAssignments(
    ::capnp::Orphan< ::AssignmentsRequest>&& value) {
  _builder.setDataField<GadgetRequest::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, GadgetRequest::MAKE_ASSIGNMENTS);
  ::capnp::_::PointerHelpers< ::AssignmentsRequest>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::AssignmentsRequest> GadgetRequest::Builder::disownMakeAssignments() {
  KJ_IREQUIRE((which() == GadgetRequest::MAKE_ASSIGNMENTS),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::AssignmentsRequest>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

#if !CAPNP_LITE
inline Parent::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline Parent::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline Parent::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline Parent::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline Parent::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::Parent::Client& Parent::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::Parent::Client& Parent::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
inline bool Parent::ConstrainParams::Reader::hasChunk() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Parent::ConstrainParams::Builder::hasChunk() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::R1CSChunk::Reader Parent::ConstrainParams::Reader::getChunk() const {
  return ::capnp::_::PointerHelpers< ::R1CSChunk>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::R1CSChunk::Builder Parent::ConstrainParams::Builder::getChunk() {
  return ::capnp::_::PointerHelpers< ::R1CSChunk>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::R1CSChunk::Pipeline Parent::ConstrainParams::Pipeline::getChunk() {
  return  ::R1CSChunk::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Parent::ConstrainParams::Builder::setChunk( ::R1CSChunk::Reader value) {
  ::capnp::_::PointerHelpers< ::R1CSChunk>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::R1CSChunk::Builder Parent::ConstrainParams::Builder::initChunk() {
  return ::capnp::_::PointerHelpers< ::R1CSChunk>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Parent::ConstrainParams::Builder::adoptChunk(
    ::capnp::Orphan< ::R1CSChunk>&& value) {
  ::capnp::_::PointerHelpers< ::R1CSChunk>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::R1CSChunk> Parent::ConstrainParams::Builder::disownChunk() {
  return ::capnp::_::PointerHelpers< ::R1CSChunk>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Parent::ConstrainResults::Reader::getOk() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool Parent::ConstrainResults::Builder::getOk() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Parent::ConstrainResults::Builder::setOk(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Parent::AssignParams::Reader::hasChunk() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Parent::AssignParams::Builder::hasChunk() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::AssignmentsChunk::Reader Parent::AssignParams::Reader::getChunk() const {
  return ::capnp::_::PointerHelpers< ::AssignmentsChunk>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::AssignmentsChunk::Builder Parent::AssignParams::Builder::getChunk() {
  return ::capnp::_::PointerHelpers< ::AssignmentsChunk>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::AssignmentsChunk::Pipeline Parent::AssignParams::Pipeline::getChunk() {
  return  ::AssignmentsChunk::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Parent::AssignParams::Builder::setChunk( ::AssignmentsChunk::Reader value) {
  ::capnp::_::PointerHelpers< ::AssignmentsChunk>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::AssignmentsChunk::Builder Parent::AssignParams::Builder::initChunk() {
  return ::capnp::_::PointerHelpers< ::AssignmentsChunk>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Parent::AssignParams::Builder::adoptChunk(
    ::capnp::Orphan< ::AssignmentsChunk>&& value) {
  ::capnp::_::PointerHelpers< ::AssignmentsChunk>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::AssignmentsChunk> Parent::AssignParams::Builder::disownChunk() {
  return ::capnp::_::PointerHelpers< ::AssignmentsChunk>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Parent::AssignResults::Reader::getOk() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool Parent::AssignResults::Builder::getOk() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Parent::AssignResults::Builder::setOk(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

#if !CAPNP_LITE
inline Gadget::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline Gadget::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline Gadget::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline Gadget::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline Gadget::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::Gadget::Client& Gadget::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::Gadget::Client& Gadget::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
inline bool Gadget::MakeR1CSParams::Reader::hasParams() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Gadget::MakeR1CSParams::Builder::hasParams() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::R1CSRequest::Reader Gadget::MakeR1CSParams::Reader::getParams() const {
  return ::capnp::_::PointerHelpers< ::R1CSRequest>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::R1CSRequest::Builder Gadget::MakeR1CSParams::Builder::getParams() {
  return ::capnp::_::PointerHelpers< ::R1CSRequest>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::R1CSRequest::Pipeline Gadget::MakeR1CSParams::Pipeline::getParams() {
  return  ::R1CSRequest::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Gadget::MakeR1CSParams::Builder::setParams( ::R1CSRequest::Reader value) {
  ::capnp::_::PointerHelpers< ::R1CSRequest>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::R1CSRequest::Builder Gadget::MakeR1CSParams::Builder::initParams() {
  return ::capnp::_::PointerHelpers< ::R1CSRequest>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Gadget::MakeR1CSParams::Builder::adoptParams(
    ::capnp::Orphan< ::R1CSRequest>&& value) {
  ::capnp::_::PointerHelpers< ::R1CSRequest>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::R1CSRequest> Gadget::MakeR1CSParams::Builder::disownParams() {
  return ::capnp::_::PointerHelpers< ::R1CSRequest>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Gadget::MakeR1CSParams::Reader::hasCaller() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Gadget::MakeR1CSParams::Builder::hasCaller() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::Parent::Client Gadget::MakeR1CSParams::Reader::getCaller() const {
  return ::capnp::_::PointerHelpers< ::Parent>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::Parent::Client Gadget::MakeR1CSParams::Builder::getCaller() {
  return ::capnp::_::PointerHelpers< ::Parent>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::Parent::Client Gadget::MakeR1CSParams::Pipeline::getCaller() {
  return  ::Parent::Client(_typeless.getPointerField(1).asCap());
}
inline void Gadget::MakeR1CSParams::Builder::setCaller( ::Parent::Client&& cap) {
  ::capnp::_::PointerHelpers< ::Parent>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void Gadget::MakeR1CSParams::Builder::setCaller( ::Parent::Client& cap) {
  ::capnp::_::PointerHelpers< ::Parent>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), cap);
}
inline void Gadget::MakeR1CSParams::Builder::adoptCaller(
    ::capnp::Orphan< ::Parent>&& value) {
  ::capnp::_::PointerHelpers< ::Parent>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Parent> Gadget::MakeR1CSParams::Builder::disownCaller() {
  return ::capnp::_::PointerHelpers< ::Parent>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline bool Gadget::MakeR1CSResults::Reader::hasRes() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Gadget::MakeR1CSResults::Builder::hasRes() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::R1CSResponse::Reader Gadget::MakeR1CSResults::Reader::getRes() const {
  return ::capnp::_::PointerHelpers< ::R1CSResponse>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::R1CSResponse::Builder Gadget::MakeR1CSResults::Builder::getRes() {
  return ::capnp::_::PointerHelpers< ::R1CSResponse>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::R1CSResponse::Pipeline Gadget::MakeR1CSResults::Pipeline::getRes() {
  return  ::R1CSResponse::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Gadget::MakeR1CSResults::Builder::setRes( ::R1CSResponse::Reader value) {
  ::capnp::_::PointerHelpers< ::R1CSResponse>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::R1CSResponse::Builder Gadget::MakeR1CSResults::Builder::initRes() {
  return ::capnp::_::PointerHelpers< ::R1CSResponse>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Gadget::MakeR1CSResults::Builder::adoptRes(
    ::capnp::Orphan< ::R1CSResponse>&& value) {
  ::capnp::_::PointerHelpers< ::R1CSResponse>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::R1CSResponse> Gadget::MakeR1CSResults::Builder::disownRes() {
  return ::capnp::_::PointerHelpers< ::R1CSResponse>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Gadget::MakeAssignmentsParams::Reader::hasParams() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Gadget::MakeAssignmentsParams::Builder::hasParams() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::AssignmentsRequest::Reader Gadget::MakeAssignmentsParams::Reader::getParams() const {
  return ::capnp::_::PointerHelpers< ::AssignmentsRequest>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::AssignmentsRequest::Builder Gadget::MakeAssignmentsParams::Builder::getParams() {
  return ::capnp::_::PointerHelpers< ::AssignmentsRequest>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::AssignmentsRequest::Pipeline Gadget::MakeAssignmentsParams::Pipeline::getParams() {
  return  ::AssignmentsRequest::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Gadget::MakeAssignmentsParams::Builder::setParams( ::AssignmentsRequest::Reader value) {
  ::capnp::_::PointerHelpers< ::AssignmentsRequest>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::AssignmentsRequest::Builder Gadget::MakeAssignmentsParams::Builder::initParams() {
  return ::capnp::_::PointerHelpers< ::AssignmentsRequest>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Gadget::MakeAssignmentsParams::Builder::adoptParams(
    ::capnp::Orphan< ::AssignmentsRequest>&& value) {
  ::capnp::_::PointerHelpers< ::AssignmentsRequest>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::AssignmentsRequest> Gadget::MakeAssignmentsParams::Builder::disownParams() {
  return ::capnp::_::PointerHelpers< ::AssignmentsRequest>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Gadget::MakeAssignmentsParams::Reader::hasCaller() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Gadget::MakeAssignmentsParams::Builder::hasCaller() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::Parent::Client Gadget::MakeAssignmentsParams::Reader::getCaller() const {
  return ::capnp::_::PointerHelpers< ::Parent>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::Parent::Client Gadget::MakeAssignmentsParams::Builder::getCaller() {
  return ::capnp::_::PointerHelpers< ::Parent>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::Parent::Client Gadget::MakeAssignmentsParams::Pipeline::getCaller() {
  return  ::Parent::Client(_typeless.getPointerField(1).asCap());
}
inline void Gadget::MakeAssignmentsParams::Builder::setCaller( ::Parent::Client&& cap) {
  ::capnp::_::PointerHelpers< ::Parent>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(cap));
}
inline void Gadget::MakeAssignmentsParams::Builder::setCaller( ::Parent::Client& cap) {
  ::capnp::_::PointerHelpers< ::Parent>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), cap);
}
inline void Gadget::MakeAssignmentsParams::Builder::adoptCaller(
    ::capnp::Orphan< ::Parent>&& value) {
  ::capnp::_::PointerHelpers< ::Parent>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Parent> Gadget::MakeAssignmentsParams::Builder::disownCaller() {
  return ::capnp::_::PointerHelpers< ::Parent>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline bool Gadget::MakeAssignmentsResults::Reader::hasRes() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Gadget::MakeAssignmentsResults::Builder::hasRes() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::AssignmentsResponse::Reader Gadget::MakeAssignmentsResults::Reader::getRes() const {
  return ::capnp::_::PointerHelpers< ::AssignmentsResponse>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::AssignmentsResponse::Builder Gadget::MakeAssignmentsResults::Builder::getRes() {
  return ::capnp::_::PointerHelpers< ::AssignmentsResponse>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::AssignmentsResponse::Pipeline Gadget::MakeAssignmentsResults::Pipeline::getRes() {
  return  ::AssignmentsResponse::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Gadget::MakeAssignmentsResults::Builder::setRes( ::AssignmentsResponse::Reader value) {
  ::capnp::_::PointerHelpers< ::AssignmentsResponse>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::AssignmentsResponse::Builder Gadget::MakeAssignmentsResults::Builder::initRes() {
  return ::capnp::_::PointerHelpers< ::AssignmentsResponse>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Gadget::MakeAssignmentsResults::Builder::adoptRes(
    ::capnp::Orphan< ::AssignmentsResponse>&& value) {
  ::capnp::_::PointerHelpers< ::AssignmentsResponse>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::AssignmentsResponse> Gadget::MakeAssignmentsResults::Builder::disownRes() {
  return ::capnp::_::PointerHelpers< ::AssignmentsResponse>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}


