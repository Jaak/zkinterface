// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_GADGET_GADGET_H_
#define FLATBUFFERS_GENERATED_GADGET_GADGET_H_

#include "flatbuffers/flatbuffers.h"

namespace Gadget {

struct Root;

struct LinearCombination;

struct Constraint;

struct GadgetInstance;

struct R1CSRequest;

struct R1CSConstraints;

struct R1CSResponse;

struct AssignmentsRequest;

struct AssignedVariables;

struct AssignmentsResponse;

struct CustomKeyValue;

struct FieldElementRepresentation;

struct StructuredConnection;

struct GadgetDescription;

struct GadgetsDescriptionRequest;

struct GadgetsDescriptionResponse;

enum Message {
  Message_NONE = 0,
  Message_GadgetsDescriptionRequest = 1,
  Message_GadgetsDescriptionResponse = 2,
  Message_R1CSRequest = 3,
  Message_R1CSConstraints = 4,
  Message_R1CSResponse = 5,
  Message_AssignmentsRequest = 6,
  Message_AssignedVariables = 7,
  Message_AssignmentsResponse = 8,
  Message_MIN = Message_NONE,
  Message_MAX = Message_AssignmentsResponse
};

inline const Message (&EnumValuesMessage())[9] {
  static const Message values[] = {
    Message_NONE,
    Message_GadgetsDescriptionRequest,
    Message_GadgetsDescriptionResponse,
    Message_R1CSRequest,
    Message_R1CSConstraints,
    Message_R1CSResponse,
    Message_AssignmentsRequest,
    Message_AssignedVariables,
    Message_AssignmentsResponse
  };
  return values;
}

inline const char * const *EnumNamesMessage() {
  static const char * const names[] = {
    "NONE",
    "GadgetsDescriptionRequest",
    "GadgetsDescriptionResponse",
    "R1CSRequest",
    "R1CSConstraints",
    "R1CSResponse",
    "AssignmentsRequest",
    "AssignedVariables",
    "AssignmentsResponse",
    nullptr
  };
  return names;
}

inline const char *EnumNameMessage(Message e) {
  if (e < Message_NONE || e > Message_AssignmentsResponse) return "";
  const size_t index = static_cast<int>(e);
  return EnumNamesMessage()[index];
}

template<typename T> struct MessageTraits {
  static const Message enum_value = Message_NONE;
};

template<> struct MessageTraits<GadgetsDescriptionRequest> {
  static const Message enum_value = Message_GadgetsDescriptionRequest;
};

template<> struct MessageTraits<GadgetsDescriptionResponse> {
  static const Message enum_value = Message_GadgetsDescriptionResponse;
};

template<> struct MessageTraits<R1CSRequest> {
  static const Message enum_value = Message_R1CSRequest;
};

template<> struct MessageTraits<R1CSConstraints> {
  static const Message enum_value = Message_R1CSConstraints;
};

template<> struct MessageTraits<R1CSResponse> {
  static const Message enum_value = Message_R1CSResponse;
};

template<> struct MessageTraits<AssignmentsRequest> {
  static const Message enum_value = Message_AssignmentsRequest;
};

template<> struct MessageTraits<AssignedVariables> {
  static const Message enum_value = Message_AssignedVariables;
};

template<> struct MessageTraits<AssignmentsResponse> {
  static const Message enum_value = Message_AssignmentsResponse;
};

bool VerifyMessage(flatbuffers::Verifier &verifier, const void *obj, Message type);
bool VerifyMessageVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct Root FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGE_TYPE = 4,
    VT_MESSAGE = 6
  };
  Message message_type() const {
    return static_cast<Message>(GetField<uint8_t>(VT_MESSAGE_TYPE, 0));
  }
  const void *message() const {
    return GetPointer<const void *>(VT_MESSAGE);
  }
  template<typename T> const T *message_as() const;
  const GadgetsDescriptionRequest *message_as_GadgetsDescriptionRequest() const {
    return message_type() == Message_GadgetsDescriptionRequest ? static_cast<const GadgetsDescriptionRequest *>(message()) : nullptr;
  }
  const GadgetsDescriptionResponse *message_as_GadgetsDescriptionResponse() const {
    return message_type() == Message_GadgetsDescriptionResponse ? static_cast<const GadgetsDescriptionResponse *>(message()) : nullptr;
  }
  const R1CSRequest *message_as_R1CSRequest() const {
    return message_type() == Message_R1CSRequest ? static_cast<const R1CSRequest *>(message()) : nullptr;
  }
  const R1CSConstraints *message_as_R1CSConstraints() const {
    return message_type() == Message_R1CSConstraints ? static_cast<const R1CSConstraints *>(message()) : nullptr;
  }
  const R1CSResponse *message_as_R1CSResponse() const {
    return message_type() == Message_R1CSResponse ? static_cast<const R1CSResponse *>(message()) : nullptr;
  }
  const AssignmentsRequest *message_as_AssignmentsRequest() const {
    return message_type() == Message_AssignmentsRequest ? static_cast<const AssignmentsRequest *>(message()) : nullptr;
  }
  const AssignedVariables *message_as_AssignedVariables() const {
    return message_type() == Message_AssignedVariables ? static_cast<const AssignedVariables *>(message()) : nullptr;
  }
  const AssignmentsResponse *message_as_AssignmentsResponse() const {
    return message_type() == Message_AssignmentsResponse ? static_cast<const AssignmentsResponse *>(message()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MESSAGE_TYPE) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           VerifyMessage(verifier, message(), message_type()) &&
           verifier.EndTable();
  }
};

template<> inline const GadgetsDescriptionRequest *Root::message_as<GadgetsDescriptionRequest>() const {
  return message_as_GadgetsDescriptionRequest();
}

template<> inline const GadgetsDescriptionResponse *Root::message_as<GadgetsDescriptionResponse>() const {
  return message_as_GadgetsDescriptionResponse();
}

template<> inline const R1CSRequest *Root::message_as<R1CSRequest>() const {
  return message_as_R1CSRequest();
}

template<> inline const R1CSConstraints *Root::message_as<R1CSConstraints>() const {
  return message_as_R1CSConstraints();
}

template<> inline const R1CSResponse *Root::message_as<R1CSResponse>() const {
  return message_as_R1CSResponse();
}

template<> inline const AssignmentsRequest *Root::message_as<AssignmentsRequest>() const {
  return message_as_AssignmentsRequest();
}

template<> inline const AssignedVariables *Root::message_as<AssignedVariables>() const {
  return message_as_AssignedVariables();
}

template<> inline const AssignmentsResponse *Root::message_as<AssignmentsResponse>() const {
  return message_as_AssignmentsResponse();
}

struct RootBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_message_type(Message message_type) {
    fbb_.AddElement<uint8_t>(Root::VT_MESSAGE_TYPE, static_cast<uint8_t>(message_type), 0);
  }
  void add_message(flatbuffers::Offset<void> message) {
    fbb_.AddOffset(Root::VT_MESSAGE, message);
  }
  explicit RootBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RootBuilder &operator=(const RootBuilder &);
  flatbuffers::Offset<Root> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Root>(end);
    return o;
  }
};

inline flatbuffers::Offset<Root> CreateRoot(
    flatbuffers::FlatBufferBuilder &_fbb,
    Message message_type = Message_NONE,
    flatbuffers::Offset<void> message = 0) {
  RootBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_message_type(message_type);
  return builder_.Finish();
}

/// The terms in a R1CS linear combination.
struct LinearCombination FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VARIABLE_IDS = 4,
    VT_COEFFICIENTS = 6
  };
  const flatbuffers::Vector<uint64_t> *variable_ids() const {
    return GetPointer<const flatbuffers::Vector<uint64_t> *>(VT_VARIABLE_IDS);
  }
  /// Contiguous constant coefficient representations in the same order as variable_ids.
  const flatbuffers::Vector<uint8_t> *coefficients() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_COEFFICIENTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VARIABLE_IDS) &&
           verifier.VerifyVector(variable_ids()) &&
           VerifyOffset(verifier, VT_COEFFICIENTS) &&
           verifier.VerifyVector(coefficients()) &&
           verifier.EndTable();
  }
};

struct LinearCombinationBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_variable_ids(flatbuffers::Offset<flatbuffers::Vector<uint64_t>> variable_ids) {
    fbb_.AddOffset(LinearCombination::VT_VARIABLE_IDS, variable_ids);
  }
  void add_coefficients(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> coefficients) {
    fbb_.AddOffset(LinearCombination::VT_COEFFICIENTS, coefficients);
  }
  explicit LinearCombinationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LinearCombinationBuilder &operator=(const LinearCombinationBuilder &);
  flatbuffers::Offset<LinearCombination> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LinearCombination>(end);
    return o;
  }
};

inline flatbuffers::Offset<LinearCombination> CreateLinearCombination(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint64_t>> variable_ids = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> coefficients = 0) {
  LinearCombinationBuilder builder_(_fbb);
  builder_.add_coefficients(coefficients);
  builder_.add_variable_ids(variable_ids);
  return builder_.Finish();
}

inline flatbuffers::Offset<LinearCombination> CreateLinearCombinationDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint64_t> *variable_ids = nullptr,
    const std::vector<uint8_t> *coefficients = nullptr) {
  auto variable_ids__ = variable_ids ? _fbb.CreateVector<uint64_t>(*variable_ids) : 0;
  auto coefficients__ = coefficients ? _fbb.CreateVector<uint8_t>(*coefficients) : 0;
  return Gadget::CreateLinearCombination(
      _fbb,
      variable_ids__,
      coefficients__);
}

/// A low-level R1CS constraint between variables.
/// Targets the generic mechanisms that build circuits.
/// Intended to be sent in sequences.
struct Constraint FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_A = 4,
    VT_B = 6,
    VT_C = 8
  };
  const LinearCombination *a() const {
    return GetPointer<const LinearCombination *>(VT_A);
  }
  const LinearCombination *b() const {
    return GetPointer<const LinearCombination *>(VT_B);
  }
  const LinearCombination *c() const {
    return GetPointer<const LinearCombination *>(VT_C);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_A) &&
           verifier.VerifyTable(a()) &&
           VerifyOffset(verifier, VT_B) &&
           verifier.VerifyTable(b()) &&
           VerifyOffset(verifier, VT_C) &&
           verifier.VerifyTable(c()) &&
           verifier.EndTable();
  }
};

struct ConstraintBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_a(flatbuffers::Offset<LinearCombination> a) {
    fbb_.AddOffset(Constraint::VT_A, a);
  }
  void add_b(flatbuffers::Offset<LinearCombination> b) {
    fbb_.AddOffset(Constraint::VT_B, b);
  }
  void add_c(flatbuffers::Offset<LinearCombination> c) {
    fbb_.AddOffset(Constraint::VT_C, c);
  }
  explicit ConstraintBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ConstraintBuilder &operator=(const ConstraintBuilder &);
  flatbuffers::Offset<Constraint> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Constraint>(end);
    return o;
  }
};

inline flatbuffers::Offset<Constraint> CreateConstraint(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<LinearCombination> a = 0,
    flatbuffers::Offset<LinearCombination> b = 0,
    flatbuffers::Offset<LinearCombination> c = 0) {
  ConstraintBuilder builder_(_fbb);
  builder_.add_c(c);
  builder_.add_b(b);
  builder_.add_a(a);
  return builder_.Finish();
}

/// An instance of a gadget as part of a circuit.
struct GadgetInstance FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_GADGET_NAME = 4,
    VT_INCOMING_VARIABLE_IDS = 6,
    VT_OUTGOING_VARIABLE_IDS = 8,
    VT_FREE_VARIABLE_ID_BEFORE = 10,
    VT_PARAMETERS = 12
  };
  /// Which gadget to instantiate.
  /// Allows a library to provide multiple gadgets.
  const flatbuffers::String *gadget_name() const {
    return GetPointer<const flatbuffers::String *>(VT_GADGET_NAME);
  }
  /// Variables allocated by the caller to use as connections to the gadget.
  /// Incoming variables are assigned by the calling parent.
  const flatbuffers::Vector<uint64_t> *incoming_variable_ids() const {
    return GetPointer<const flatbuffers::Vector<uint64_t> *>(VT_INCOMING_VARIABLE_IDS);
  }
  /// Variables allocated by the caller to use as connections to the gadget.
  /// Outgoing variables are assigned by the called gadget.
  /// There may be no outgoing variables if the gadget represents a pure assertion.
  const flatbuffers::Vector<uint64_t> *outgoing_variable_ids() const {
    return GetPointer<const flatbuffers::Vector<uint64_t> *>(VT_OUTGOING_VARIABLE_IDS);
  }
  /// First free variable ID before the call.
  /// The gadget can allocate IDs greater or equal.
  uint64_t free_variable_id_before() const {
    return GetField<uint64_t>(VT_FREE_VARIABLE_ID_BEFORE, 0);
  }
  /// Optional: Any parameter that may influence the instance behavior.
  /// Parameters can be standard, conventional, or specific to a gadget.
  const flatbuffers::Vector<flatbuffers::Offset<CustomKeyValue>> *parameters() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<CustomKeyValue>> *>(VT_PARAMETERS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_GADGET_NAME) &&
           verifier.VerifyString(gadget_name()) &&
           VerifyOffset(verifier, VT_INCOMING_VARIABLE_IDS) &&
           verifier.VerifyVector(incoming_variable_ids()) &&
           VerifyOffset(verifier, VT_OUTGOING_VARIABLE_IDS) &&
           verifier.VerifyVector(outgoing_variable_ids()) &&
           VerifyField<uint64_t>(verifier, VT_FREE_VARIABLE_ID_BEFORE) &&
           VerifyOffset(verifier, VT_PARAMETERS) &&
           verifier.VerifyVector(parameters()) &&
           verifier.VerifyVectorOfTables(parameters()) &&
           verifier.EndTable();
  }
};

struct GadgetInstanceBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_gadget_name(flatbuffers::Offset<flatbuffers::String> gadget_name) {
    fbb_.AddOffset(GadgetInstance::VT_GADGET_NAME, gadget_name);
  }
  void add_incoming_variable_ids(flatbuffers::Offset<flatbuffers::Vector<uint64_t>> incoming_variable_ids) {
    fbb_.AddOffset(GadgetInstance::VT_INCOMING_VARIABLE_IDS, incoming_variable_ids);
  }
  void add_outgoing_variable_ids(flatbuffers::Offset<flatbuffers::Vector<uint64_t>> outgoing_variable_ids) {
    fbb_.AddOffset(GadgetInstance::VT_OUTGOING_VARIABLE_IDS, outgoing_variable_ids);
  }
  void add_free_variable_id_before(uint64_t free_variable_id_before) {
    fbb_.AddElement<uint64_t>(GadgetInstance::VT_FREE_VARIABLE_ID_BEFORE, free_variable_id_before, 0);
  }
  void add_parameters(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CustomKeyValue>>> parameters) {
    fbb_.AddOffset(GadgetInstance::VT_PARAMETERS, parameters);
  }
  explicit GadgetInstanceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GadgetInstanceBuilder &operator=(const GadgetInstanceBuilder &);
  flatbuffers::Offset<GadgetInstance> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GadgetInstance>(end);
    return o;
  }
};

inline flatbuffers::Offset<GadgetInstance> CreateGadgetInstance(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> gadget_name = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint64_t>> incoming_variable_ids = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint64_t>> outgoing_variable_ids = 0,
    uint64_t free_variable_id_before = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CustomKeyValue>>> parameters = 0) {
  GadgetInstanceBuilder builder_(_fbb);
  builder_.add_free_variable_id_before(free_variable_id_before);
  builder_.add_parameters(parameters);
  builder_.add_outgoing_variable_ids(outgoing_variable_ids);
  builder_.add_incoming_variable_ids(incoming_variable_ids);
  builder_.add_gadget_name(gadget_name);
  return builder_.Finish();
}

inline flatbuffers::Offset<GadgetInstance> CreateGadgetInstanceDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *gadget_name = nullptr,
    const std::vector<uint64_t> *incoming_variable_ids = nullptr,
    const std::vector<uint64_t> *outgoing_variable_ids = nullptr,
    uint64_t free_variable_id_before = 0,
    const std::vector<flatbuffers::Offset<CustomKeyValue>> *parameters = nullptr) {
  auto gadget_name__ = gadget_name ? _fbb.CreateString(gadget_name) : 0;
  auto incoming_variable_ids__ = incoming_variable_ids ? _fbb.CreateVector<uint64_t>(*incoming_variable_ids) : 0;
  auto outgoing_variable_ids__ = outgoing_variable_ids ? _fbb.CreateVector<uint64_t>(*outgoing_variable_ids) : 0;
  auto parameters__ = parameters ? _fbb.CreateVector<flatbuffers::Offset<CustomKeyValue>>(*parameters) : 0;
  return Gadget::CreateGadgetInstance(
      _fbb,
      gadget_name__,
      incoming_variable_ids__,
      outgoing_variable_ids__,
      free_variable_id_before,
      parameters__);
}

/// Request to build an instance.
struct R1CSRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INSTANCE = 4
  };
  /// All details necessary to construct the instance.
  /// The same instance parameter must be provided in the corresponding AssignmentsRequest.
  const GadgetInstance *instance() const {
    return GetPointer<const GadgetInstance *>(VT_INSTANCE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INSTANCE) &&
           verifier.VerifyTable(instance()) &&
           verifier.EndTable();
  }
};

struct R1CSRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_instance(flatbuffers::Offset<GadgetInstance> instance) {
    fbb_.AddOffset(R1CSRequest::VT_INSTANCE, instance);
  }
  explicit R1CSRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  R1CSRequestBuilder &operator=(const R1CSRequestBuilder &);
  flatbuffers::Offset<R1CSRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<R1CSRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<R1CSRequest> CreateR1CSRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<GadgetInstance> instance = 0) {
  R1CSRequestBuilder builder_(_fbb);
  builder_.add_instance(instance);
  return builder_.Finish();
}

/// Report constraints to be added to the constraints system.
/// To send to the stream of constraints.
struct R1CSConstraints FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONSTRAINTS = 4,
    VT_REPRESENTATION = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<Constraint>> *constraints() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Constraint>> *>(VT_CONSTRAINTS);
  }
  /// Optional: The representation used for the constraint coefficients, if non-default.
  const FieldElementRepresentation *representation() const {
    return GetPointer<const FieldElementRepresentation *>(VT_REPRESENTATION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CONSTRAINTS) &&
           verifier.VerifyVector(constraints()) &&
           verifier.VerifyVectorOfTables(constraints()) &&
           VerifyOffset(verifier, VT_REPRESENTATION) &&
           verifier.VerifyTable(representation()) &&
           verifier.EndTable();
  }
};

struct R1CSConstraintsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_constraints(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Constraint>>> constraints) {
    fbb_.AddOffset(R1CSConstraints::VT_CONSTRAINTS, constraints);
  }
  void add_representation(flatbuffers::Offset<FieldElementRepresentation> representation) {
    fbb_.AddOffset(R1CSConstraints::VT_REPRESENTATION, representation);
  }
  explicit R1CSConstraintsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  R1CSConstraintsBuilder &operator=(const R1CSConstraintsBuilder &);
  flatbuffers::Offset<R1CSConstraints> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<R1CSConstraints>(end);
    return o;
  }
};

inline flatbuffers::Offset<R1CSConstraints> CreateR1CSConstraints(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Constraint>>> constraints = 0,
    flatbuffers::Offset<FieldElementRepresentation> representation = 0) {
  R1CSConstraintsBuilder builder_(_fbb);
  builder_.add_representation(representation);
  builder_.add_constraints(constraints);
  return builder_.Finish();
}

inline flatbuffers::Offset<R1CSConstraints> CreateR1CSConstraintsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Constraint>> *constraints = nullptr,
    flatbuffers::Offset<FieldElementRepresentation> representation = 0) {
  auto constraints__ = constraints ? _fbb.CreateVector<flatbuffers::Offset<Constraint>>(*constraints) : 0;
  return Gadget::CreateR1CSConstraints(
      _fbb,
      constraints__,
      representation);
}

/// Response after all R1CSConstraints have been sent.
struct R1CSResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FREE_VARIABLE_ID_AFTER = 4,
    VT_INFO = 6,
    VT_ERROR = 8
  };
  /// First variable ID free after the gadget call.
  /// A variable ID greater than all IDs allocated by the gadget.
  uint64_t free_variable_id_after() const {
    return GetField<uint64_t>(VT_FREE_VARIABLE_ID_AFTER, 0);
  }
  /// Optional: Any info that may be useful to the calling parent.
  const flatbuffers::Vector<flatbuffers::Offset<CustomKeyValue>> *info() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<CustomKeyValue>> *>(VT_INFO);
  }
  /// Optional: An error message. Null if no error.
  const flatbuffers::String *error() const {
    return GetPointer<const flatbuffers::String *>(VT_ERROR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_FREE_VARIABLE_ID_AFTER) &&
           VerifyOffset(verifier, VT_INFO) &&
           verifier.VerifyVector(info()) &&
           verifier.VerifyVectorOfTables(info()) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyString(error()) &&
           verifier.EndTable();
  }
};

struct R1CSResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_free_variable_id_after(uint64_t free_variable_id_after) {
    fbb_.AddElement<uint64_t>(R1CSResponse::VT_FREE_VARIABLE_ID_AFTER, free_variable_id_after, 0);
  }
  void add_info(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CustomKeyValue>>> info) {
    fbb_.AddOffset(R1CSResponse::VT_INFO, info);
  }
  void add_error(flatbuffers::Offset<flatbuffers::String> error) {
    fbb_.AddOffset(R1CSResponse::VT_ERROR, error);
  }
  explicit R1CSResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  R1CSResponseBuilder &operator=(const R1CSResponseBuilder &);
  flatbuffers::Offset<R1CSResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<R1CSResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<R1CSResponse> CreateR1CSResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t free_variable_id_after = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CustomKeyValue>>> info = 0,
    flatbuffers::Offset<flatbuffers::String> error = 0) {
  R1CSResponseBuilder builder_(_fbb);
  builder_.add_free_variable_id_after(free_variable_id_after);
  builder_.add_error(error);
  builder_.add_info(info);
  return builder_.Finish();
}

inline flatbuffers::Offset<R1CSResponse> CreateR1CSResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t free_variable_id_after = 0,
    const std::vector<flatbuffers::Offset<CustomKeyValue>> *info = nullptr,
    const char *error = nullptr) {
  auto info__ = info ? _fbb.CreateVector<flatbuffers::Offset<CustomKeyValue>>(*info) : 0;
  auto error__ = error ? _fbb.CreateString(error) : 0;
  return Gadget::CreateR1CSResponse(
      _fbb,
      free_variable_id_after,
      info__,
      error__);
}

/// Request assignments computed from a witness.
struct AssignmentsRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INSTANCE = 4,
    VT_INCOMING_ELEMENTS = 6,
    VT_REPRESENTATION = 8,
    VT_WITNESS = 10
  };
  /// All details necessary to construct the instance.
  /// The same instance parameter must be provided as in the corresponding R1CSRequest.
  const GadgetInstance *instance() const {
    return GetPointer<const GadgetInstance *>(VT_INSTANCE);
  }
  /// The values that the parent assigned to `instance.incoming_variable_ids`.
  const flatbuffers::Vector<uint8_t> *incoming_elements() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_INCOMING_ELEMENTS);
  }
  /// Optional: The representation used for the incoming_elements, if non-default.
  const FieldElementRepresentation *representation() const {
    return GetPointer<const FieldElementRepresentation *>(VT_REPRESENTATION);
  }
  /// Optional: Any info that may be useful to the gadget to compute its assignments.
  const flatbuffers::Vector<flatbuffers::Offset<CustomKeyValue>> *witness() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<CustomKeyValue>> *>(VT_WITNESS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INSTANCE) &&
           verifier.VerifyTable(instance()) &&
           VerifyOffset(verifier, VT_INCOMING_ELEMENTS) &&
           verifier.VerifyVector(incoming_elements()) &&
           VerifyOffset(verifier, VT_REPRESENTATION) &&
           verifier.VerifyTable(representation()) &&
           VerifyOffset(verifier, VT_WITNESS) &&
           verifier.VerifyVector(witness()) &&
           verifier.VerifyVectorOfTables(witness()) &&
           verifier.EndTable();
  }
};

struct AssignmentsRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_instance(flatbuffers::Offset<GadgetInstance> instance) {
    fbb_.AddOffset(AssignmentsRequest::VT_INSTANCE, instance);
  }
  void add_incoming_elements(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> incoming_elements) {
    fbb_.AddOffset(AssignmentsRequest::VT_INCOMING_ELEMENTS, incoming_elements);
  }
  void add_representation(flatbuffers::Offset<FieldElementRepresentation> representation) {
    fbb_.AddOffset(AssignmentsRequest::VT_REPRESENTATION, representation);
  }
  void add_witness(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CustomKeyValue>>> witness) {
    fbb_.AddOffset(AssignmentsRequest::VT_WITNESS, witness);
  }
  explicit AssignmentsRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AssignmentsRequestBuilder &operator=(const AssignmentsRequestBuilder &);
  flatbuffers::Offset<AssignmentsRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AssignmentsRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<AssignmentsRequest> CreateAssignmentsRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<GadgetInstance> instance = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> incoming_elements = 0,
    flatbuffers::Offset<FieldElementRepresentation> representation = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CustomKeyValue>>> witness = 0) {
  AssignmentsRequestBuilder builder_(_fbb);
  builder_.add_witness(witness);
  builder_.add_representation(representation);
  builder_.add_incoming_elements(incoming_elements);
  builder_.add_instance(instance);
  return builder_.Finish();
}

inline flatbuffers::Offset<AssignmentsRequest> CreateAssignmentsRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<GadgetInstance> instance = 0,
    const std::vector<uint8_t> *incoming_elements = nullptr,
    flatbuffers::Offset<FieldElementRepresentation> representation = 0,
    const std::vector<flatbuffers::Offset<CustomKeyValue>> *witness = nullptr) {
  auto incoming_elements__ = incoming_elements ? _fbb.CreateVector<uint8_t>(*incoming_elements) : 0;
  auto witness__ = witness ? _fbb.CreateVector<flatbuffers::Offset<CustomKeyValue>>(*witness) : 0;
  return Gadget::CreateAssignmentsRequest(
      _fbb,
      instance,
      incoming_elements__,
      representation,
      witness__);
}

/// Report local and outgoing assignments computed by the gadget.
/// To send to the stream of assigned variables.
struct AssignedVariables FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VARIABLE_IDS = 4,
    VT_ELEMENTS = 6,
    VT_REPRESENTATION = 8
  };
  /// The IDs of the variables being assigned to.
  const flatbuffers::Vector<uint64_t> *variable_ids() const {
    return GetPointer<const flatbuffers::Vector<uint64_t> *>(VT_VARIABLE_IDS);
  }
  /// Contiguous element representations in the same order as variable_ids.
  const flatbuffers::Vector<uint8_t> *elements() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_ELEMENTS);
  }
  /// Optional: The representation used for the elements, if non-default.
  const FieldElementRepresentation *representation() const {
    return GetPointer<const FieldElementRepresentation *>(VT_REPRESENTATION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VARIABLE_IDS) &&
           verifier.VerifyVector(variable_ids()) &&
           VerifyOffset(verifier, VT_ELEMENTS) &&
           verifier.VerifyVector(elements()) &&
           VerifyOffset(verifier, VT_REPRESENTATION) &&
           verifier.VerifyTable(representation()) &&
           verifier.EndTable();
  }
};

struct AssignedVariablesBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_variable_ids(flatbuffers::Offset<flatbuffers::Vector<uint64_t>> variable_ids) {
    fbb_.AddOffset(AssignedVariables::VT_VARIABLE_IDS, variable_ids);
  }
  void add_elements(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> elements) {
    fbb_.AddOffset(AssignedVariables::VT_ELEMENTS, elements);
  }
  void add_representation(flatbuffers::Offset<FieldElementRepresentation> representation) {
    fbb_.AddOffset(AssignedVariables::VT_REPRESENTATION, representation);
  }
  explicit AssignedVariablesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AssignedVariablesBuilder &operator=(const AssignedVariablesBuilder &);
  flatbuffers::Offset<AssignedVariables> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AssignedVariables>(end);
    return o;
  }
};

inline flatbuffers::Offset<AssignedVariables> CreateAssignedVariables(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint64_t>> variable_ids = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> elements = 0,
    flatbuffers::Offset<FieldElementRepresentation> representation = 0) {
  AssignedVariablesBuilder builder_(_fbb);
  builder_.add_representation(representation);
  builder_.add_elements(elements);
  builder_.add_variable_ids(variable_ids);
  return builder_.Finish();
}

inline flatbuffers::Offset<AssignedVariables> CreateAssignedVariablesDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint64_t> *variable_ids = nullptr,
    const std::vector<uint8_t> *elements = nullptr,
    flatbuffers::Offset<FieldElementRepresentation> representation = 0) {
  auto variable_ids__ = variable_ids ? _fbb.CreateVector<uint64_t>(*variable_ids) : 0;
  auto elements__ = elements ? _fbb.CreateVector<uint8_t>(*elements) : 0;
  return Gadget::CreateAssignedVariables(
      _fbb,
      variable_ids__,
      elements__,
      representation);
}

/// Response after all AssignedVariables have been sent.
struct AssignmentsResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FREE_VARIABLE_ID_AFTER = 4,
    VT_OUTGOING_ELEMENTS = 6,
    VT_REPRESENTATION = 8,
    VT_INFO = 10,
    VT_ERROR = 12
  };
  /// First variable ID free after the gadget call.
  /// A variable ID greater than all IDs allocated by the gadget.
  uint64_t free_variable_id_after() const {
    return GetField<uint64_t>(VT_FREE_VARIABLE_ID_AFTER, 0);
  }
  /// The values that the gadget assigned to `instance.outgoing_variable_ids`.
  /// Intentionally redundant with AssignedVariables to allow handling
  /// the outgoing variables separately from the bulk of local variables assignments.
  const flatbuffers::Vector<uint8_t> *outgoing_elements() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_OUTGOING_ELEMENTS);
  }
  /// Optional: The representation used for the outgoingAssignments, if non-default.
  const FieldElementRepresentation *representation() const {
    return GetPointer<const FieldElementRepresentation *>(VT_REPRESENTATION);
  }
  /// Optional: Any info that may be useful to the calling parent.
  const flatbuffers::Vector<flatbuffers::Offset<CustomKeyValue>> *info() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<CustomKeyValue>> *>(VT_INFO);
  }
  /// Optional: An error message. Null if no error.
  const flatbuffers::String *error() const {
    return GetPointer<const flatbuffers::String *>(VT_ERROR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_FREE_VARIABLE_ID_AFTER) &&
           VerifyOffset(verifier, VT_OUTGOING_ELEMENTS) &&
           verifier.VerifyVector(outgoing_elements()) &&
           VerifyOffset(verifier, VT_REPRESENTATION) &&
           verifier.VerifyTable(representation()) &&
           VerifyOffset(verifier, VT_INFO) &&
           verifier.VerifyVector(info()) &&
           verifier.VerifyVectorOfTables(info()) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyString(error()) &&
           verifier.EndTable();
  }
};

struct AssignmentsResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_free_variable_id_after(uint64_t free_variable_id_after) {
    fbb_.AddElement<uint64_t>(AssignmentsResponse::VT_FREE_VARIABLE_ID_AFTER, free_variable_id_after, 0);
  }
  void add_outgoing_elements(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> outgoing_elements) {
    fbb_.AddOffset(AssignmentsResponse::VT_OUTGOING_ELEMENTS, outgoing_elements);
  }
  void add_representation(flatbuffers::Offset<FieldElementRepresentation> representation) {
    fbb_.AddOffset(AssignmentsResponse::VT_REPRESENTATION, representation);
  }
  void add_info(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CustomKeyValue>>> info) {
    fbb_.AddOffset(AssignmentsResponse::VT_INFO, info);
  }
  void add_error(flatbuffers::Offset<flatbuffers::String> error) {
    fbb_.AddOffset(AssignmentsResponse::VT_ERROR, error);
  }
  explicit AssignmentsResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AssignmentsResponseBuilder &operator=(const AssignmentsResponseBuilder &);
  flatbuffers::Offset<AssignmentsResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AssignmentsResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<AssignmentsResponse> CreateAssignmentsResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t free_variable_id_after = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> outgoing_elements = 0,
    flatbuffers::Offset<FieldElementRepresentation> representation = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CustomKeyValue>>> info = 0,
    flatbuffers::Offset<flatbuffers::String> error = 0) {
  AssignmentsResponseBuilder builder_(_fbb);
  builder_.add_free_variable_id_after(free_variable_id_after);
  builder_.add_error(error);
  builder_.add_info(info);
  builder_.add_representation(representation);
  builder_.add_outgoing_elements(outgoing_elements);
  return builder_.Finish();
}

inline flatbuffers::Offset<AssignmentsResponse> CreateAssignmentsResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t free_variable_id_after = 0,
    const std::vector<uint8_t> *outgoing_elements = nullptr,
    flatbuffers::Offset<FieldElementRepresentation> representation = 0,
    const std::vector<flatbuffers::Offset<CustomKeyValue>> *info = nullptr,
    const char *error = nullptr) {
  auto outgoing_elements__ = outgoing_elements ? _fbb.CreateVector<uint8_t>(*outgoing_elements) : 0;
  auto info__ = info ? _fbb.CreateVector<flatbuffers::Offset<CustomKeyValue>>(*info) : 0;
  auto error__ = error ? _fbb.CreateString(error) : 0;
  return Gadget::CreateAssignmentsResponse(
      _fbb,
      free_variable_id_after,
      outgoing_elements__,
      representation,
      info__,
      error__);
}

/// Generic key-value for miscellaneous attributes.
struct CustomKeyValue FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_VALUE = 6
  };
  const flatbuffers::String *key() const {
    return GetPointer<const flatbuffers::String *>(VT_KEY);
  }
  const flatbuffers::Vector<uint8_t> *value() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KEY) &&
           verifier.VerifyString(key()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           verifier.EndTable();
  }
};

struct CustomKeyValueBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_key(flatbuffers::Offset<flatbuffers::String> key) {
    fbb_.AddOffset(CustomKeyValue::VT_KEY, key);
  }
  void add_value(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> value) {
    fbb_.AddOffset(CustomKeyValue::VT_VALUE, value);
  }
  explicit CustomKeyValueBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CustomKeyValueBuilder &operator=(const CustomKeyValueBuilder &);
  flatbuffers::Offset<CustomKeyValue> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CustomKeyValue>(end);
    return o;
  }
};

inline flatbuffers::Offset<CustomKeyValue> CreateCustomKeyValue(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> key = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> value = 0) {
  CustomKeyValueBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_key(key);
  return builder_.Finish();
}

inline flatbuffers::Offset<CustomKeyValue> CreateCustomKeyValueDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *key = nullptr,
    const std::vector<uint8_t> *value = nullptr) {
  auto key__ = key ? _fbb.CreateString(key) : 0;
  auto value__ = value ? _fbb.CreateVector<uint8_t>(*value) : 0;
  return Gadget::CreateCustomKeyValue(
      _fbb,
      key__,
      value__);
}

/// Description of the representation or encoding of field elements.
/// All messages that transmit field elements should include it.
/// If omitted, assume the recommended representation:
/// name = "little-endian"
/// size = 32 bytes
///
/// There are two ways to use this information:
/// - Simply check it, and return an error if the representation is incorrect.
/// - Or write generic code that converts automatically when necessary.
///
struct FieldElementRepresentation FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_SIZE = 6
  };
  /// The well-known name of the representation.
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  /// Optional: The size of the representation of an element in bytes, if fixed-size.
  uint32_t size() const {
    return GetField<uint32_t>(VT_SIZE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint32_t>(verifier, VT_SIZE) &&
           verifier.EndTable();
  }
};

struct FieldElementRepresentationBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(FieldElementRepresentation::VT_NAME, name);
  }
  void add_size(uint32_t size) {
    fbb_.AddElement<uint32_t>(FieldElementRepresentation::VT_SIZE, size, 0);
  }
  explicit FieldElementRepresentationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FieldElementRepresentationBuilder &operator=(const FieldElementRepresentationBuilder &);
  flatbuffers::Offset<FieldElementRepresentation> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FieldElementRepresentation>(end);
    return o;
  }
};

inline flatbuffers::Offset<FieldElementRepresentation> CreateFieldElementRepresentation(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    uint32_t size = 0) {
  FieldElementRepresentationBuilder builder_(_fbb);
  builder_.add_size(size);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<FieldElementRepresentation> CreateFieldElementRepresentationDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    uint32_t size = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return Gadget::CreateFieldElementRepresentation(
      _fbb,
      name__,
      size);
}

/// A high-level structure of variables for type safety.
/// A structure describes the semantics over a flat array of variables.
/// Define the interface between a gadget and the rest of the circuit.
/// In gadget composition, the parent provides these structures to its child.
/// A gadget should document what structures it can accept.
struct StructuredConnection FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VARIABLE_COUNT = 4,
    VT_STRUCTURES = 6,
    VT_NAME = 8,
    VT_INFO = 10
  };
  /// How many variables make up this connection.
  uint64_t variable_count() const {
    return GetField<uint64_t>(VT_VARIABLE_COUNT, 0);
  }
  /// Optional: recursive type.
  /// The inner structures describe subsequent segments of the variables array.
  const flatbuffers::Vector<flatbuffers::Offset<StructuredConnection>> *structures() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<StructuredConnection>> *>(VT_STRUCTURES);
  }
  /// Optional: Name of the connection.
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  /// Optional: Any custom information.
  const flatbuffers::Vector<flatbuffers::Offset<CustomKeyValue>> *info() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<CustomKeyValue>> *>(VT_INFO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_VARIABLE_COUNT) &&
           VerifyOffset(verifier, VT_STRUCTURES) &&
           verifier.VerifyVector(structures()) &&
           verifier.VerifyVectorOfTables(structures()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INFO) &&
           verifier.VerifyVector(info()) &&
           verifier.VerifyVectorOfTables(info()) &&
           verifier.EndTable();
  }
};

struct StructuredConnectionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_variable_count(uint64_t variable_count) {
    fbb_.AddElement<uint64_t>(StructuredConnection::VT_VARIABLE_COUNT, variable_count, 0);
  }
  void add_structures(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<StructuredConnection>>> structures) {
    fbb_.AddOffset(StructuredConnection::VT_STRUCTURES, structures);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(StructuredConnection::VT_NAME, name);
  }
  void add_info(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CustomKeyValue>>> info) {
    fbb_.AddOffset(StructuredConnection::VT_INFO, info);
  }
  explicit StructuredConnectionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StructuredConnectionBuilder &operator=(const StructuredConnectionBuilder &);
  flatbuffers::Offset<StructuredConnection> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StructuredConnection>(end);
    return o;
  }
};

inline flatbuffers::Offset<StructuredConnection> CreateStructuredConnection(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t variable_count = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<StructuredConnection>>> structures = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CustomKeyValue>>> info = 0) {
  StructuredConnectionBuilder builder_(_fbb);
  builder_.add_variable_count(variable_count);
  builder_.add_info(info);
  builder_.add_name(name);
  builder_.add_structures(structures);
  return builder_.Finish();
}

inline flatbuffers::Offset<StructuredConnection> CreateStructuredConnectionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t variable_count = 0,
    const std::vector<flatbuffers::Offset<StructuredConnection>> *structures = nullptr,
    const char *name = nullptr,
    const std::vector<flatbuffers::Offset<CustomKeyValue>> *info = nullptr) {
  auto structures__ = structures ? _fbb.CreateVector<flatbuffers::Offset<StructuredConnection>>(*structures) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto info__ = info ? _fbb.CreateVector<flatbuffers::Offset<CustomKeyValue>>(*info) : 0;
  return Gadget::CreateStructuredConnection(
      _fbb,
      variable_count,
      structures__,
      name__,
      info__);
}

/// A description of the types that a gadget expects.
/// Used to provide type safety.
struct GadgetDescription FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_GADGET_NAME = 4,
    VT_INCOMING_CONNECTION = 6,
    VT_OUTGOING_CONNECTION = 8,
    VT_SUPPORTED_REPRESENTATIONS = 10,
    VT_INFO = 12
  };
  /// Name of the gadget.
  /// Use in other request to select a gadget.
  const flatbuffers::String *gadget_name() const {
    return GetPointer<const flatbuffers::String *>(VT_GADGET_NAME);
  }
  /// Describe the structure of the incoming array of variables.
  const StructuredConnection *incoming_connection() const {
    return GetPointer<const StructuredConnection *>(VT_INCOMING_CONNECTION);
  }
  /// Describe the structure of the outgoing array of variables.
  const StructuredConnection *outgoing_connection() const {
    return GetPointer<const StructuredConnection *>(VT_OUTGOING_CONNECTION);
  }
  /// The representations of field elements supported by this gadget.
  const flatbuffers::Vector<flatbuffers::Offset<FieldElementRepresentation>> *supported_representations() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FieldElementRepresentation>> *>(VT_SUPPORTED_REPRESENTATIONS);
  }
  /// Any custom information.
  const flatbuffers::Vector<flatbuffers::Offset<CustomKeyValue>> *info() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<CustomKeyValue>> *>(VT_INFO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_GADGET_NAME) &&
           verifier.VerifyString(gadget_name()) &&
           VerifyOffset(verifier, VT_INCOMING_CONNECTION) &&
           verifier.VerifyTable(incoming_connection()) &&
           VerifyOffset(verifier, VT_OUTGOING_CONNECTION) &&
           verifier.VerifyTable(outgoing_connection()) &&
           VerifyOffset(verifier, VT_SUPPORTED_REPRESENTATIONS) &&
           verifier.VerifyVector(supported_representations()) &&
           verifier.VerifyVectorOfTables(supported_representations()) &&
           VerifyOffset(verifier, VT_INFO) &&
           verifier.VerifyVector(info()) &&
           verifier.VerifyVectorOfTables(info()) &&
           verifier.EndTable();
  }
};

struct GadgetDescriptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_gadget_name(flatbuffers::Offset<flatbuffers::String> gadget_name) {
    fbb_.AddOffset(GadgetDescription::VT_GADGET_NAME, gadget_name);
  }
  void add_incoming_connection(flatbuffers::Offset<StructuredConnection> incoming_connection) {
    fbb_.AddOffset(GadgetDescription::VT_INCOMING_CONNECTION, incoming_connection);
  }
  void add_outgoing_connection(flatbuffers::Offset<StructuredConnection> outgoing_connection) {
    fbb_.AddOffset(GadgetDescription::VT_OUTGOING_CONNECTION, outgoing_connection);
  }
  void add_supported_representations(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FieldElementRepresentation>>> supported_representations) {
    fbb_.AddOffset(GadgetDescription::VT_SUPPORTED_REPRESENTATIONS, supported_representations);
  }
  void add_info(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CustomKeyValue>>> info) {
    fbb_.AddOffset(GadgetDescription::VT_INFO, info);
  }
  explicit GadgetDescriptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GadgetDescriptionBuilder &operator=(const GadgetDescriptionBuilder &);
  flatbuffers::Offset<GadgetDescription> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GadgetDescription>(end);
    return o;
  }
};

inline flatbuffers::Offset<GadgetDescription> CreateGadgetDescription(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> gadget_name = 0,
    flatbuffers::Offset<StructuredConnection> incoming_connection = 0,
    flatbuffers::Offset<StructuredConnection> outgoing_connection = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FieldElementRepresentation>>> supported_representations = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CustomKeyValue>>> info = 0) {
  GadgetDescriptionBuilder builder_(_fbb);
  builder_.add_info(info);
  builder_.add_supported_representations(supported_representations);
  builder_.add_outgoing_connection(outgoing_connection);
  builder_.add_incoming_connection(incoming_connection);
  builder_.add_gadget_name(gadget_name);
  return builder_.Finish();
}

inline flatbuffers::Offset<GadgetDescription> CreateGadgetDescriptionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *gadget_name = nullptr,
    flatbuffers::Offset<StructuredConnection> incoming_connection = 0,
    flatbuffers::Offset<StructuredConnection> outgoing_connection = 0,
    const std::vector<flatbuffers::Offset<FieldElementRepresentation>> *supported_representations = nullptr,
    const std::vector<flatbuffers::Offset<CustomKeyValue>> *info = nullptr) {
  auto gadget_name__ = gadget_name ? _fbb.CreateString(gadget_name) : 0;
  auto supported_representations__ = supported_representations ? _fbb.CreateVector<flatbuffers::Offset<FieldElementRepresentation>>(*supported_representations) : 0;
  auto info__ = info ? _fbb.CreateVector<flatbuffers::Offset<CustomKeyValue>>(*info) : 0;
  return Gadget::CreateGadgetDescription(
      _fbb,
      gadget_name__,
      incoming_connection,
      outgoing_connection,
      supported_representations__,
      info__);
}

struct GadgetsDescriptionRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct GadgetsDescriptionRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit GadgetsDescriptionRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GadgetsDescriptionRequestBuilder &operator=(const GadgetsDescriptionRequestBuilder &);
  flatbuffers::Offset<GadgetsDescriptionRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GadgetsDescriptionRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<GadgetsDescriptionRequest> CreateGadgetsDescriptionRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  GadgetsDescriptionRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

struct GadgetsDescriptionResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_GADGETS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<GadgetDescription>> *gadgets() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<GadgetDescription>> *>(VT_GADGETS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_GADGETS) &&
           verifier.VerifyVector(gadgets()) &&
           verifier.VerifyVectorOfTables(gadgets()) &&
           verifier.EndTable();
  }
};

struct GadgetsDescriptionResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_gadgets(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GadgetDescription>>> gadgets) {
    fbb_.AddOffset(GadgetsDescriptionResponse::VT_GADGETS, gadgets);
  }
  explicit GadgetsDescriptionResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GadgetsDescriptionResponseBuilder &operator=(const GadgetsDescriptionResponseBuilder &);
  flatbuffers::Offset<GadgetsDescriptionResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GadgetsDescriptionResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<GadgetsDescriptionResponse> CreateGadgetsDescriptionResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GadgetDescription>>> gadgets = 0) {
  GadgetsDescriptionResponseBuilder builder_(_fbb);
  builder_.add_gadgets(gadgets);
  return builder_.Finish();
}

inline flatbuffers::Offset<GadgetsDescriptionResponse> CreateGadgetsDescriptionResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<GadgetDescription>> *gadgets = nullptr) {
  auto gadgets__ = gadgets ? _fbb.CreateVector<flatbuffers::Offset<GadgetDescription>>(*gadgets) : 0;
  return Gadget::CreateGadgetsDescriptionResponse(
      _fbb,
      gadgets__);
}

inline bool VerifyMessage(flatbuffers::Verifier &verifier, const void *obj, Message type) {
  switch (type) {
    case Message_NONE: {
      return true;
    }
    case Message_GadgetsDescriptionRequest: {
      auto ptr = reinterpret_cast<const GadgetsDescriptionRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_GadgetsDescriptionResponse: {
      auto ptr = reinterpret_cast<const GadgetsDescriptionResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_R1CSRequest: {
      auto ptr = reinterpret_cast<const R1CSRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_R1CSConstraints: {
      auto ptr = reinterpret_cast<const R1CSConstraints *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_R1CSResponse: {
      auto ptr = reinterpret_cast<const R1CSResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_AssignmentsRequest: {
      auto ptr = reinterpret_cast<const AssignmentsRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_AssignedVariables: {
      auto ptr = reinterpret_cast<const AssignedVariables *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_AssignmentsResponse: {
      auto ptr = reinterpret_cast<const AssignmentsResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyMessageVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyMessage(
        verifier,  values->Get(i), types->GetEnum<Message>(i))) {
      return false;
    }
  }
  return true;
}

inline const Gadget::Root *GetRoot(const void *buf) {
  return flatbuffers::GetRoot<Gadget::Root>(buf);
}

inline const Gadget::Root *GetSizePrefixedRoot(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<Gadget::Root>(buf);
}

inline const char *RootIdentifier() {
  return "zkco";
}

inline bool RootBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, RootIdentifier());
}

inline bool VerifyRootBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Gadget::Root>(RootIdentifier());
}

inline bool VerifySizePrefixedRootBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Gadget::Root>(RootIdentifier());
}

inline const char *RootExtension() {
  return "zkco";
}

inline void FinishRootBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<Gadget::Root> root) {
  fbb.Finish(root, RootIdentifier());
}

inline void FinishSizePrefixedRootBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<Gadget::Root> root) {
  fbb.FinishSizePrefixed(root, RootIdentifier());
}

}  // namespace Gadget

#endif  // FLATBUFFERS_GENERATED_GADGET_GADGET_H_
