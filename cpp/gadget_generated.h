// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_GADGET_GADGET_H_
#define FLATBUFFERS_GENERATED_GADGET_GADGET_H_

#include "flatbuffers/flatbuffers.h"

namespace Gadget {

struct Root;

struct FieldElementRepresentation;

struct Terms;

struct Constraint;

struct AssignedVariables;

struct CustomKeyValue;

struct StructuredConnection;

struct GadgetInstance;

struct R1CSRequest;

struct R1CSChunk;

struct R1CSResponse;

struct AssignmentsRequest;

struct AssignmentsChunk;

struct AssignmentsResponse;

enum Message {
  Message_NONE = 0,
  Message_R1CSRequest = 1,
  Message_R1CSChunk = 2,
  Message_R1CSResponse = 3,
  Message_AssignmentsRequest = 4,
  Message_AssignmentsChunk = 5,
  Message_AssignmentsResponse = 6,
  Message_MIN = Message_NONE,
  Message_MAX = Message_AssignmentsResponse
};

inline const Message (&EnumValuesMessage())[7] {
  static const Message values[] = {
    Message_NONE,
    Message_R1CSRequest,
    Message_R1CSChunk,
    Message_R1CSResponse,
    Message_AssignmentsRequest,
    Message_AssignmentsChunk,
    Message_AssignmentsResponse
  };
  return values;
}

inline const char * const *EnumNamesMessage() {
  static const char * const names[] = {
    "NONE",
    "R1CSRequest",
    "R1CSChunk",
    "R1CSResponse",
    "AssignmentsRequest",
    "AssignmentsChunk",
    "AssignmentsResponse",
    nullptr
  };
  return names;
}

inline const char *EnumNameMessage(Message e) {
  if (e < Message_NONE || e > Message_AssignmentsResponse) return "";
  const size_t index = static_cast<int>(e);
  return EnumNamesMessage()[index];
}

template<typename T> struct MessageTraits {
  static const Message enum_value = Message_NONE;
};

template<> struct MessageTraits<R1CSRequest> {
  static const Message enum_value = Message_R1CSRequest;
};

template<> struct MessageTraits<R1CSChunk> {
  static const Message enum_value = Message_R1CSChunk;
};

template<> struct MessageTraits<R1CSResponse> {
  static const Message enum_value = Message_R1CSResponse;
};

template<> struct MessageTraits<AssignmentsRequest> {
  static const Message enum_value = Message_AssignmentsRequest;
};

template<> struct MessageTraits<AssignmentsChunk> {
  static const Message enum_value = Message_AssignmentsChunk;
};

template<> struct MessageTraits<AssignmentsResponse> {
  static const Message enum_value = Message_AssignmentsResponse;
};

bool VerifyMessage(flatbuffers::Verifier &verifier, const void *obj, Message type);
bool VerifyMessageVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct Root FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGE_TYPE = 4,
    VT_MESSAGE = 6
  };
  Message message_type() const {
    return static_cast<Message>(GetField<uint8_t>(VT_MESSAGE_TYPE, 0));
  }
  const void *message() const {
    return GetPointer<const void *>(VT_MESSAGE);
  }
  template<typename T> const T *message_as() const;
  const R1CSRequest *message_as_R1CSRequest() const {
    return message_type() == Message_R1CSRequest ? static_cast<const R1CSRequest *>(message()) : nullptr;
  }
  const R1CSChunk *message_as_R1CSChunk() const {
    return message_type() == Message_R1CSChunk ? static_cast<const R1CSChunk *>(message()) : nullptr;
  }
  const R1CSResponse *message_as_R1CSResponse() const {
    return message_type() == Message_R1CSResponse ? static_cast<const R1CSResponse *>(message()) : nullptr;
  }
  const AssignmentsRequest *message_as_AssignmentsRequest() const {
    return message_type() == Message_AssignmentsRequest ? static_cast<const AssignmentsRequest *>(message()) : nullptr;
  }
  const AssignmentsChunk *message_as_AssignmentsChunk() const {
    return message_type() == Message_AssignmentsChunk ? static_cast<const AssignmentsChunk *>(message()) : nullptr;
  }
  const AssignmentsResponse *message_as_AssignmentsResponse() const {
    return message_type() == Message_AssignmentsResponse ? static_cast<const AssignmentsResponse *>(message()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MESSAGE_TYPE) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           VerifyMessage(verifier, message(), message_type()) &&
           verifier.EndTable();
  }
};

template<> inline const R1CSRequest *Root::message_as<R1CSRequest>() const {
  return message_as_R1CSRequest();
}

template<> inline const R1CSChunk *Root::message_as<R1CSChunk>() const {
  return message_as_R1CSChunk();
}

template<> inline const R1CSResponse *Root::message_as<R1CSResponse>() const {
  return message_as_R1CSResponse();
}

template<> inline const AssignmentsRequest *Root::message_as<AssignmentsRequest>() const {
  return message_as_AssignmentsRequest();
}

template<> inline const AssignmentsChunk *Root::message_as<AssignmentsChunk>() const {
  return message_as_AssignmentsChunk();
}

template<> inline const AssignmentsResponse *Root::message_as<AssignmentsResponse>() const {
  return message_as_AssignmentsResponse();
}

struct RootBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_message_type(Message message_type) {
    fbb_.AddElement<uint8_t>(Root::VT_MESSAGE_TYPE, static_cast<uint8_t>(message_type), 0);
  }
  void add_message(flatbuffers::Offset<void> message) {
    fbb_.AddOffset(Root::VT_MESSAGE, message);
  }
  explicit RootBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RootBuilder &operator=(const RootBuilder &);
  flatbuffers::Offset<Root> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Root>(end);
    return o;
  }
};

inline flatbuffers::Offset<Root> CreateRoot(
    flatbuffers::FlatBufferBuilder &_fbb,
    Message message_type = Message_NONE,
    flatbuffers::Offset<void> message = 0) {
  RootBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_message_type(message_type);
  return builder_.Finish();
}

/// Description of the representation or encoding of field elements.
/// If omitted, use a default representation:
/// name = "little-endian"
/// size = 32 bytes
struct FieldElementRepresentation FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_SIZE = 6
  };
  /// The well-known name of the representation.
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  /// The size of the representation of an element in bytes.
  uint32_t size() const {
    return GetField<uint32_t>(VT_SIZE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint32_t>(verifier, VT_SIZE) &&
           verifier.EndTable();
  }
};

struct FieldElementRepresentationBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(FieldElementRepresentation::VT_NAME, name);
  }
  void add_size(uint32_t size) {
    fbb_.AddElement<uint32_t>(FieldElementRepresentation::VT_SIZE, size, 0);
  }
  explicit FieldElementRepresentationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FieldElementRepresentationBuilder &operator=(const FieldElementRepresentationBuilder &);
  flatbuffers::Offset<FieldElementRepresentation> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FieldElementRepresentation>(end);
    return o;
  }
};

inline flatbuffers::Offset<FieldElementRepresentation> CreateFieldElementRepresentation(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    uint32_t size = 0) {
  FieldElementRepresentationBuilder builder_(_fbb);
  builder_.add_size(size);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<FieldElementRepresentation> CreateFieldElementRepresentationDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    uint32_t size = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return Gadget::CreateFieldElementRepresentation(
      _fbb,
      name__,
      size);
}

/// Terms in a R1CS vector.
struct Terms FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VARIABLE_IDS = 4,
    VT_COEFFICIENTS = 6
  };
  const flatbuffers::Vector<uint64_t> *variable_ids() const {
    return GetPointer<const flatbuffers::Vector<uint64_t> *>(VT_VARIABLE_IDS);
  }
  /// Contiguous coefficient representations in the same order as variable_ids.
  const flatbuffers::Vector<uint8_t> *coefficients() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_COEFFICIENTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VARIABLE_IDS) &&
           verifier.VerifyVector(variable_ids()) &&
           VerifyOffset(verifier, VT_COEFFICIENTS) &&
           verifier.VerifyVector(coefficients()) &&
           verifier.EndTable();
  }
};

struct TermsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_variable_ids(flatbuffers::Offset<flatbuffers::Vector<uint64_t>> variable_ids) {
    fbb_.AddOffset(Terms::VT_VARIABLE_IDS, variable_ids);
  }
  void add_coefficients(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> coefficients) {
    fbb_.AddOffset(Terms::VT_COEFFICIENTS, coefficients);
  }
  explicit TermsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TermsBuilder &operator=(const TermsBuilder &);
  flatbuffers::Offset<Terms> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Terms>(end);
    return o;
  }
};

inline flatbuffers::Offset<Terms> CreateTerms(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint64_t>> variable_ids = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> coefficients = 0) {
  TermsBuilder builder_(_fbb);
  builder_.add_coefficients(coefficients);
  builder_.add_variable_ids(variable_ids);
  return builder_.Finish();
}

inline flatbuffers::Offset<Terms> CreateTermsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint64_t> *variable_ids = nullptr,
    const std::vector<uint8_t> *coefficients = nullptr) {
  auto variable_ids__ = variable_ids ? _fbb.CreateVector<uint64_t>(*variable_ids) : 0;
  auto coefficients__ = coefficients ? _fbb.CreateVector<uint8_t>(*coefficients) : 0;
  return Gadget::CreateTerms(
      _fbb,
      variable_ids__,
      coefficients__);
}

/// A low-level R1CS constraint between variables.
/// Targets the generic mechanisms that build circuits.
/// Intended to be sent in sequences.
struct Constraint FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_A = 4,
    VT_B = 6,
    VT_C = 8
  };
  const Terms *a() const {
    return GetPointer<const Terms *>(VT_A);
  }
  const Terms *b() const {
    return GetPointer<const Terms *>(VT_B);
  }
  const Terms *c() const {
    return GetPointer<const Terms *>(VT_C);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_A) &&
           verifier.VerifyTable(a()) &&
           VerifyOffset(verifier, VT_B) &&
           verifier.VerifyTable(b()) &&
           VerifyOffset(verifier, VT_C) &&
           verifier.VerifyTable(c()) &&
           verifier.EndTable();
  }
};

struct ConstraintBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_a(flatbuffers::Offset<Terms> a) {
    fbb_.AddOffset(Constraint::VT_A, a);
  }
  void add_b(flatbuffers::Offset<Terms> b) {
    fbb_.AddOffset(Constraint::VT_B, b);
  }
  void add_c(flatbuffers::Offset<Terms> c) {
    fbb_.AddOffset(Constraint::VT_C, c);
  }
  explicit ConstraintBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ConstraintBuilder &operator=(const ConstraintBuilder &);
  flatbuffers::Offset<Constraint> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Constraint>(end);
    return o;
  }
};

inline flatbuffers::Offset<Constraint> CreateConstraint(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Terms> a = 0,
    flatbuffers::Offset<Terms> b = 0,
    flatbuffers::Offset<Terms> c = 0) {
  ConstraintBuilder builder_(_fbb);
  builder_.add_c(c);
  builder_.add_b(b);
  builder_.add_a(a);
  return builder_.Finish();
}

/// Low-level assignments to variables.
/// Targets the generic mechanisms that prepare proofs.
struct AssignedVariables FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VARIABLE_IDS = 4,
    VT_ELEMENTS = 6
  };
  /// The IDs of the variables being assigned to.
  const flatbuffers::Vector<uint64_t> *variable_ids() const {
    return GetPointer<const flatbuffers::Vector<uint64_t> *>(VT_VARIABLE_IDS);
  }
  /// Contiguous element representations in the same order as variable_ids.
  const flatbuffers::Vector<uint8_t> *elements() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_ELEMENTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VARIABLE_IDS) &&
           verifier.VerifyVector(variable_ids()) &&
           VerifyOffset(verifier, VT_ELEMENTS) &&
           verifier.VerifyVector(elements()) &&
           verifier.EndTable();
  }
};

struct AssignedVariablesBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_variable_ids(flatbuffers::Offset<flatbuffers::Vector<uint64_t>> variable_ids) {
    fbb_.AddOffset(AssignedVariables::VT_VARIABLE_IDS, variable_ids);
  }
  void add_elements(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> elements) {
    fbb_.AddOffset(AssignedVariables::VT_ELEMENTS, elements);
  }
  explicit AssignedVariablesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AssignedVariablesBuilder &operator=(const AssignedVariablesBuilder &);
  flatbuffers::Offset<AssignedVariables> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AssignedVariables>(end);
    return o;
  }
};

inline flatbuffers::Offset<AssignedVariables> CreateAssignedVariables(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint64_t>> variable_ids = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> elements = 0) {
  AssignedVariablesBuilder builder_(_fbb);
  builder_.add_elements(elements);
  builder_.add_variable_ids(variable_ids);
  return builder_.Finish();
}

inline flatbuffers::Offset<AssignedVariables> CreateAssignedVariablesDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint64_t> *variable_ids = nullptr,
    const std::vector<uint8_t> *elements = nullptr) {
  auto variable_ids__ = variable_ids ? _fbb.CreateVector<uint64_t>(*variable_ids) : 0;
  auto elements__ = elements ? _fbb.CreateVector<uint8_t>(*elements) : 0;
  return Gadget::CreateAssignedVariables(
      _fbb,
      variable_ids__,
      elements__);
}

/// Generic key-value for miscellaneous attributes.
struct CustomKeyValue FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_VALUE = 6
  };
  const flatbuffers::String *key() const {
    return GetPointer<const flatbuffers::String *>(VT_KEY);
  }
  const flatbuffers::Vector<uint8_t> *value() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KEY) &&
           verifier.VerifyString(key()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           verifier.EndTable();
  }
};

struct CustomKeyValueBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_key(flatbuffers::Offset<flatbuffers::String> key) {
    fbb_.AddOffset(CustomKeyValue::VT_KEY, key);
  }
  void add_value(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> value) {
    fbb_.AddOffset(CustomKeyValue::VT_VALUE, value);
  }
  explicit CustomKeyValueBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CustomKeyValueBuilder &operator=(const CustomKeyValueBuilder &);
  flatbuffers::Offset<CustomKeyValue> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CustomKeyValue>(end);
    return o;
  }
};

inline flatbuffers::Offset<CustomKeyValue> CreateCustomKeyValue(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> key = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> value = 0) {
  CustomKeyValueBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_key(key);
  return builder_.Finish();
}

inline flatbuffers::Offset<CustomKeyValue> CreateCustomKeyValueDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *key = nullptr,
    const std::vector<uint8_t> *value = nullptr) {
  auto key__ = key ? _fbb.CreateString(key) : 0;
  auto value__ = value ? _fbb.CreateVector<uint8_t>(*value) : 0;
  return Gadget::CreateCustomKeyValue(
      _fbb,
      key__,
      value__);
}

/// A high-level structure of variables.
/// Define the interface between a gadget and the rest of the circuit.
/// In gadget composition, the parent provides these structures to its child.
/// A gadget should document what structures it can accept.
struct StructuredConnection FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VARIABLE_IDS = 4,
    VT_STRUCTURES = 6,
    VT_NAME = 8,
    VT_INFO = 10
  };
  /// Variables allocated by the caller to use as connections to the gadget.
  const flatbuffers::Vector<uint64_t> *variable_ids() const {
    return GetPointer<const flatbuffers::Vector<uint64_t> *>(VT_VARIABLE_IDS);
  }
  /// Optionally recursive type.
  /// If used, the field `variable_ids` must be null.
  const flatbuffers::Vector<flatbuffers::Offset<StructuredConnection>> *structures() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<StructuredConnection>> *>(VT_STRUCTURES);
  }
  /// Name of the connection.
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  /// Any custom information.
  const flatbuffers::Vector<flatbuffers::Offset<CustomKeyValue>> *info() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<CustomKeyValue>> *>(VT_INFO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VARIABLE_IDS) &&
           verifier.VerifyVector(variable_ids()) &&
           VerifyOffset(verifier, VT_STRUCTURES) &&
           verifier.VerifyVector(structures()) &&
           verifier.VerifyVectorOfTables(structures()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INFO) &&
           verifier.VerifyVector(info()) &&
           verifier.VerifyVectorOfTables(info()) &&
           verifier.EndTable();
  }
};

struct StructuredConnectionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_variable_ids(flatbuffers::Offset<flatbuffers::Vector<uint64_t>> variable_ids) {
    fbb_.AddOffset(StructuredConnection::VT_VARIABLE_IDS, variable_ids);
  }
  void add_structures(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<StructuredConnection>>> structures) {
    fbb_.AddOffset(StructuredConnection::VT_STRUCTURES, structures);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(StructuredConnection::VT_NAME, name);
  }
  void add_info(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CustomKeyValue>>> info) {
    fbb_.AddOffset(StructuredConnection::VT_INFO, info);
  }
  explicit StructuredConnectionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StructuredConnectionBuilder &operator=(const StructuredConnectionBuilder &);
  flatbuffers::Offset<StructuredConnection> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StructuredConnection>(end);
    return o;
  }
};

inline flatbuffers::Offset<StructuredConnection> CreateStructuredConnection(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint64_t>> variable_ids = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<StructuredConnection>>> structures = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CustomKeyValue>>> info = 0) {
  StructuredConnectionBuilder builder_(_fbb);
  builder_.add_info(info);
  builder_.add_name(name);
  builder_.add_structures(structures);
  builder_.add_variable_ids(variable_ids);
  return builder_.Finish();
}

inline flatbuffers::Offset<StructuredConnection> CreateStructuredConnectionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint64_t> *variable_ids = nullptr,
    const std::vector<flatbuffers::Offset<StructuredConnection>> *structures = nullptr,
    const char *name = nullptr,
    const std::vector<flatbuffers::Offset<CustomKeyValue>> *info = nullptr) {
  auto variable_ids__ = variable_ids ? _fbb.CreateVector<uint64_t>(*variable_ids) : 0;
  auto structures__ = structures ? _fbb.CreateVector<flatbuffers::Offset<StructuredConnection>>(*structures) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto info__ = info ? _fbb.CreateVector<flatbuffers::Offset<CustomKeyValue>>(*info) : 0;
  return Gadget::CreateStructuredConnection(
      _fbb,
      variable_ids__,
      structures__,
      name__,
      info__);
}

/// An instance of a gadget as part of a circuit.
struct GadgetInstance FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_GADGET_NAME = 4,
    VT_PARAMETERS = 6,
    VT_INCOMING_CONNECTIONS = 8,
    VT_OUTGOING_CONNECTIONS = 10,
    VT_FREE_VARIABLE_ID = 12
  };
  /// Which gadget to instantiate.
  /// Allows a library to provide multiple gadgets.
  const flatbuffers::String *gadget_name() const {
    return GetPointer<const flatbuffers::String *>(VT_GADGET_NAME);
  }
  /// Any parameter that may influence the instance behavior.
  /// Parameters can be standard, conventional, or specific to a gadget.
  const flatbuffers::Vector<flatbuffers::Offset<CustomKeyValue>> *parameters() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<CustomKeyValue>> *>(VT_PARAMETERS);
  }
  /// Structure of variables that must be assigned by the calling parent.
  const StructuredConnection *incoming_connections() const {
    return GetPointer<const StructuredConnection *>(VT_INCOMING_CONNECTIONS);
  }
  /// Structure of variables that must be assigned by the called gadget.
  /// There may be no outgoing variables if the gadget represents a pure assertion.
  const StructuredConnection *outgoing_connections() const {
    return GetPointer<const StructuredConnection *>(VT_OUTGOING_CONNECTIONS);
  }
  /// First free variable ID. The instance can allocate IDs greater or equal.
  uint64_t free_variable_id() const {
    return GetField<uint64_t>(VT_FREE_VARIABLE_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_GADGET_NAME) &&
           verifier.VerifyString(gadget_name()) &&
           VerifyOffset(verifier, VT_PARAMETERS) &&
           verifier.VerifyVector(parameters()) &&
           verifier.VerifyVectorOfTables(parameters()) &&
           VerifyOffset(verifier, VT_INCOMING_CONNECTIONS) &&
           verifier.VerifyTable(incoming_connections()) &&
           VerifyOffset(verifier, VT_OUTGOING_CONNECTIONS) &&
           verifier.VerifyTable(outgoing_connections()) &&
           VerifyField<uint64_t>(verifier, VT_FREE_VARIABLE_ID) &&
           verifier.EndTable();
  }
};

struct GadgetInstanceBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_gadget_name(flatbuffers::Offset<flatbuffers::String> gadget_name) {
    fbb_.AddOffset(GadgetInstance::VT_GADGET_NAME, gadget_name);
  }
  void add_parameters(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CustomKeyValue>>> parameters) {
    fbb_.AddOffset(GadgetInstance::VT_PARAMETERS, parameters);
  }
  void add_incoming_connections(flatbuffers::Offset<StructuredConnection> incoming_connections) {
    fbb_.AddOffset(GadgetInstance::VT_INCOMING_CONNECTIONS, incoming_connections);
  }
  void add_outgoing_connections(flatbuffers::Offset<StructuredConnection> outgoing_connections) {
    fbb_.AddOffset(GadgetInstance::VT_OUTGOING_CONNECTIONS, outgoing_connections);
  }
  void add_free_variable_id(uint64_t free_variable_id) {
    fbb_.AddElement<uint64_t>(GadgetInstance::VT_FREE_VARIABLE_ID, free_variable_id, 0);
  }
  explicit GadgetInstanceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GadgetInstanceBuilder &operator=(const GadgetInstanceBuilder &);
  flatbuffers::Offset<GadgetInstance> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GadgetInstance>(end);
    return o;
  }
};

inline flatbuffers::Offset<GadgetInstance> CreateGadgetInstance(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> gadget_name = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CustomKeyValue>>> parameters = 0,
    flatbuffers::Offset<StructuredConnection> incoming_connections = 0,
    flatbuffers::Offset<StructuredConnection> outgoing_connections = 0,
    uint64_t free_variable_id = 0) {
  GadgetInstanceBuilder builder_(_fbb);
  builder_.add_free_variable_id(free_variable_id);
  builder_.add_outgoing_connections(outgoing_connections);
  builder_.add_incoming_connections(incoming_connections);
  builder_.add_parameters(parameters);
  builder_.add_gadget_name(gadget_name);
  return builder_.Finish();
}

inline flatbuffers::Offset<GadgetInstance> CreateGadgetInstanceDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *gadget_name = nullptr,
    const std::vector<flatbuffers::Offset<CustomKeyValue>> *parameters = nullptr,
    flatbuffers::Offset<StructuredConnection> incoming_connections = 0,
    flatbuffers::Offset<StructuredConnection> outgoing_connections = 0,
    uint64_t free_variable_id = 0) {
  auto gadget_name__ = gadget_name ? _fbb.CreateString(gadget_name) : 0;
  auto parameters__ = parameters ? _fbb.CreateVector<flatbuffers::Offset<CustomKeyValue>>(*parameters) : 0;
  return Gadget::CreateGadgetInstance(
      _fbb,
      gadget_name__,
      parameters__,
      incoming_connections,
      outgoing_connections,
      free_variable_id);
}

/// Request to build an instance.
struct R1CSRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INSTANCE = 4
  };
  /// All details necessary to construct the instance.
  /// The same instance parameter must be provided in the corresponding AssignmentsRequest.
  const GadgetInstance *instance() const {
    return GetPointer<const GadgetInstance *>(VT_INSTANCE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INSTANCE) &&
           verifier.VerifyTable(instance()) &&
           verifier.EndTable();
  }
};

struct R1CSRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_instance(flatbuffers::Offset<GadgetInstance> instance) {
    fbb_.AddOffset(R1CSRequest::VT_INSTANCE, instance);
  }
  explicit R1CSRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  R1CSRequestBuilder &operator=(const R1CSRequestBuilder &);
  flatbuffers::Offset<R1CSRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<R1CSRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<R1CSRequest> CreateR1CSRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<GadgetInstance> instance = 0) {
  R1CSRequestBuilder builder_(_fbb);
  builder_.add_instance(instance);
  return builder_.Finish();
}

/// Report all constraints in one or more chunks.
struct R1CSChunk FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONSTRAINTS = 4,
    VT_REPRESENTATION = 6
  };
  /// Constraints to add.
  const flatbuffers::Vector<flatbuffers::Offset<Constraint>> *constraints() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Constraint>> *>(VT_CONSTRAINTS);
  }
  /// The representation used for the constraints.
  const FieldElementRepresentation *representation() const {
    return GetPointer<const FieldElementRepresentation *>(VT_REPRESENTATION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CONSTRAINTS) &&
           verifier.VerifyVector(constraints()) &&
           verifier.VerifyVectorOfTables(constraints()) &&
           VerifyOffset(verifier, VT_REPRESENTATION) &&
           verifier.VerifyTable(representation()) &&
           verifier.EndTable();
  }
};

struct R1CSChunkBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_constraints(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Constraint>>> constraints) {
    fbb_.AddOffset(R1CSChunk::VT_CONSTRAINTS, constraints);
  }
  void add_representation(flatbuffers::Offset<FieldElementRepresentation> representation) {
    fbb_.AddOffset(R1CSChunk::VT_REPRESENTATION, representation);
  }
  explicit R1CSChunkBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  R1CSChunkBuilder &operator=(const R1CSChunkBuilder &);
  flatbuffers::Offset<R1CSChunk> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<R1CSChunk>(end);
    return o;
  }
};

inline flatbuffers::Offset<R1CSChunk> CreateR1CSChunk(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Constraint>>> constraints = 0,
    flatbuffers::Offset<FieldElementRepresentation> representation = 0) {
  R1CSChunkBuilder builder_(_fbb);
  builder_.add_representation(representation);
  builder_.add_constraints(constraints);
  return builder_.Finish();
}

inline flatbuffers::Offset<R1CSChunk> CreateR1CSChunkDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Constraint>> *constraints = nullptr,
    flatbuffers::Offset<FieldElementRepresentation> representation = 0) {
  auto constraints__ = constraints ? _fbb.CreateVector<flatbuffers::Offset<Constraint>>(*constraints) : 0;
  return Gadget::CreateR1CSChunk(
      _fbb,
      constraints__,
      representation);
}

/// Response after the instantiation is complete.
struct R1CSResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FREE_VARIABLE_ID = 4,
    VT_INFO = 6,
    VT_ERROR = 8
  };
  /// A variable ID greater than all IDs allocated by the instance.
  uint64_t free_variable_id() const {
    return GetField<uint64_t>(VT_FREE_VARIABLE_ID, 0);
  }
  /// Any info that may be useful to the calling parent.
  const flatbuffers::Vector<flatbuffers::Offset<CustomKeyValue>> *info() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<CustomKeyValue>> *>(VT_INFO);
  }
  /// An error message. Null if no error.
  const flatbuffers::String *error() const {
    return GetPointer<const flatbuffers::String *>(VT_ERROR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_FREE_VARIABLE_ID) &&
           VerifyOffset(verifier, VT_INFO) &&
           verifier.VerifyVector(info()) &&
           verifier.VerifyVectorOfTables(info()) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyString(error()) &&
           verifier.EndTable();
  }
};

struct R1CSResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_free_variable_id(uint64_t free_variable_id) {
    fbb_.AddElement<uint64_t>(R1CSResponse::VT_FREE_VARIABLE_ID, free_variable_id, 0);
  }
  void add_info(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CustomKeyValue>>> info) {
    fbb_.AddOffset(R1CSResponse::VT_INFO, info);
  }
  void add_error(flatbuffers::Offset<flatbuffers::String> error) {
    fbb_.AddOffset(R1CSResponse::VT_ERROR, error);
  }
  explicit R1CSResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  R1CSResponseBuilder &operator=(const R1CSResponseBuilder &);
  flatbuffers::Offset<R1CSResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<R1CSResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<R1CSResponse> CreateR1CSResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t free_variable_id = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CustomKeyValue>>> info = 0,
    flatbuffers::Offset<flatbuffers::String> error = 0) {
  R1CSResponseBuilder builder_(_fbb);
  builder_.add_free_variable_id(free_variable_id);
  builder_.add_error(error);
  builder_.add_info(info);
  return builder_.Finish();
}

inline flatbuffers::Offset<R1CSResponse> CreateR1CSResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t free_variable_id = 0,
    const std::vector<flatbuffers::Offset<CustomKeyValue>> *info = nullptr,
    const char *error = nullptr) {
  auto info__ = info ? _fbb.CreateVector<flatbuffers::Offset<CustomKeyValue>>(*info) : 0;
  auto error__ = error ? _fbb.CreateString(error) : 0;
  return Gadget::CreateR1CSResponse(
      _fbb,
      free_variable_id,
      info__,
      error__);
}

/// Request assignments computed from a witness.
struct AssignmentsRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INSTANCE = 4,
    VT_WITNESS = 6,
    VT_INCOMING_ASSIGNMENTS = 8,
    VT_REPRESENTATION = 10
  };
  /// All details necessary to construct the instance.
  /// The same instance parameter must be provided as in the corresponding R1CSRequest.
  const GadgetInstance *instance() const {
    return GetPointer<const GadgetInstance *>(VT_INSTANCE);
  }
  /// Any info that may be useful to the gadget to compute its assignments.
  const flatbuffers::Vector<flatbuffers::Offset<CustomKeyValue>> *witness() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<CustomKeyValue>> *>(VT_WITNESS);
  }
  /// The values that the parent assigned to `instance.incomingConnections`.
  const AssignedVariables *incoming_assignments() const {
    return GetPointer<const AssignedVariables *>(VT_INCOMING_ASSIGNMENTS);
  }
  /// The representation used for the incomingAssignments.
  const FieldElementRepresentation *representation() const {
    return GetPointer<const FieldElementRepresentation *>(VT_REPRESENTATION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INSTANCE) &&
           verifier.VerifyTable(instance()) &&
           VerifyOffset(verifier, VT_WITNESS) &&
           verifier.VerifyVector(witness()) &&
           verifier.VerifyVectorOfTables(witness()) &&
           VerifyOffset(verifier, VT_INCOMING_ASSIGNMENTS) &&
           verifier.VerifyTable(incoming_assignments()) &&
           VerifyOffset(verifier, VT_REPRESENTATION) &&
           verifier.VerifyTable(representation()) &&
           verifier.EndTable();
  }
};

struct AssignmentsRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_instance(flatbuffers::Offset<GadgetInstance> instance) {
    fbb_.AddOffset(AssignmentsRequest::VT_INSTANCE, instance);
  }
  void add_witness(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CustomKeyValue>>> witness) {
    fbb_.AddOffset(AssignmentsRequest::VT_WITNESS, witness);
  }
  void add_incoming_assignments(flatbuffers::Offset<AssignedVariables> incoming_assignments) {
    fbb_.AddOffset(AssignmentsRequest::VT_INCOMING_ASSIGNMENTS, incoming_assignments);
  }
  void add_representation(flatbuffers::Offset<FieldElementRepresentation> representation) {
    fbb_.AddOffset(AssignmentsRequest::VT_REPRESENTATION, representation);
  }
  explicit AssignmentsRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AssignmentsRequestBuilder &operator=(const AssignmentsRequestBuilder &);
  flatbuffers::Offset<AssignmentsRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AssignmentsRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<AssignmentsRequest> CreateAssignmentsRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<GadgetInstance> instance = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CustomKeyValue>>> witness = 0,
    flatbuffers::Offset<AssignedVariables> incoming_assignments = 0,
    flatbuffers::Offset<FieldElementRepresentation> representation = 0) {
  AssignmentsRequestBuilder builder_(_fbb);
  builder_.add_representation(representation);
  builder_.add_incoming_assignments(incoming_assignments);
  builder_.add_witness(witness);
  builder_.add_instance(instance);
  return builder_.Finish();
}

inline flatbuffers::Offset<AssignmentsRequest> CreateAssignmentsRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<GadgetInstance> instance = 0,
    const std::vector<flatbuffers::Offset<CustomKeyValue>> *witness = nullptr,
    flatbuffers::Offset<AssignedVariables> incoming_assignments = 0,
    flatbuffers::Offset<FieldElementRepresentation> representation = 0) {
  auto witness__ = witness ? _fbb.CreateVector<flatbuffers::Offset<CustomKeyValue>>(*witness) : 0;
  return Gadget::CreateAssignmentsRequest(
      _fbb,
      instance,
      witness__,
      incoming_assignments,
      representation);
}

/// Report local and outgoing assignments in one or more chunks.
struct AssignmentsChunk FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ASSIGNED_VARIABLES = 4,
    VT_REPRESENTATION = 6
  };
  /// Assignments computed by the gadgets.
  const AssignedVariables *assigned_variables() const {
    return GetPointer<const AssignedVariables *>(VT_ASSIGNED_VARIABLES);
  }
  /// The representation used for the assignments.
  const FieldElementRepresentation *representation() const {
    return GetPointer<const FieldElementRepresentation *>(VT_REPRESENTATION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ASSIGNED_VARIABLES) &&
           verifier.VerifyTable(assigned_variables()) &&
           VerifyOffset(verifier, VT_REPRESENTATION) &&
           verifier.VerifyTable(representation()) &&
           verifier.EndTable();
  }
};

struct AssignmentsChunkBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_assigned_variables(flatbuffers::Offset<AssignedVariables> assigned_variables) {
    fbb_.AddOffset(AssignmentsChunk::VT_ASSIGNED_VARIABLES, assigned_variables);
  }
  void add_representation(flatbuffers::Offset<FieldElementRepresentation> representation) {
    fbb_.AddOffset(AssignmentsChunk::VT_REPRESENTATION, representation);
  }
  explicit AssignmentsChunkBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AssignmentsChunkBuilder &operator=(const AssignmentsChunkBuilder &);
  flatbuffers::Offset<AssignmentsChunk> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AssignmentsChunk>(end);
    return o;
  }
};

inline flatbuffers::Offset<AssignmentsChunk> CreateAssignmentsChunk(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<AssignedVariables> assigned_variables = 0,
    flatbuffers::Offset<FieldElementRepresentation> representation = 0) {
  AssignmentsChunkBuilder builder_(_fbb);
  builder_.add_representation(representation);
  builder_.add_assigned_variables(assigned_variables);
  return builder_.Finish();
}

/// Response after all assignments have been reported.
struct AssignmentsResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FREE_VARIABLE_ID = 4,
    VT_INFO = 6,
    VT_OUTGOING_ASSIGNMENTS = 8,
    VT_REPRESENTATION = 10,
    VT_ERROR = 12
  };
  /// A variable ID greater than all IDs allocated by the instance.
  uint64_t free_variable_id() const {
    return GetField<uint64_t>(VT_FREE_VARIABLE_ID, 0);
  }
  /// Any info that may be useful to the calling parent.
  const flatbuffers::Vector<flatbuffers::Offset<CustomKeyValue>> *info() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<CustomKeyValue>> *>(VT_INFO);
  }
  /// The values that the gadget assigned to `instance.outgoingConnections`.
  /// Intentionally redundant with AssignmentsChunk to allow handling
  /// the outgoing variables separately from the bulk of local variables assignments.
  const AssignedVariables *outgoing_assignments() const {
    return GetPointer<const AssignedVariables *>(VT_OUTGOING_ASSIGNMENTS);
  }
  /// The representation used for the outgoingAssignments.
  const FieldElementRepresentation *representation() const {
    return GetPointer<const FieldElementRepresentation *>(VT_REPRESENTATION);
  }
  /// An error message. Null if no error.
  const flatbuffers::String *error() const {
    return GetPointer<const flatbuffers::String *>(VT_ERROR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_FREE_VARIABLE_ID) &&
           VerifyOffset(verifier, VT_INFO) &&
           verifier.VerifyVector(info()) &&
           verifier.VerifyVectorOfTables(info()) &&
           VerifyOffset(verifier, VT_OUTGOING_ASSIGNMENTS) &&
           verifier.VerifyTable(outgoing_assignments()) &&
           VerifyOffset(verifier, VT_REPRESENTATION) &&
           verifier.VerifyTable(representation()) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyString(error()) &&
           verifier.EndTable();
  }
};

struct AssignmentsResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_free_variable_id(uint64_t free_variable_id) {
    fbb_.AddElement<uint64_t>(AssignmentsResponse::VT_FREE_VARIABLE_ID, free_variable_id, 0);
  }
  void add_info(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CustomKeyValue>>> info) {
    fbb_.AddOffset(AssignmentsResponse::VT_INFO, info);
  }
  void add_outgoing_assignments(flatbuffers::Offset<AssignedVariables> outgoing_assignments) {
    fbb_.AddOffset(AssignmentsResponse::VT_OUTGOING_ASSIGNMENTS, outgoing_assignments);
  }
  void add_representation(flatbuffers::Offset<FieldElementRepresentation> representation) {
    fbb_.AddOffset(AssignmentsResponse::VT_REPRESENTATION, representation);
  }
  void add_error(flatbuffers::Offset<flatbuffers::String> error) {
    fbb_.AddOffset(AssignmentsResponse::VT_ERROR, error);
  }
  explicit AssignmentsResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AssignmentsResponseBuilder &operator=(const AssignmentsResponseBuilder &);
  flatbuffers::Offset<AssignmentsResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AssignmentsResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<AssignmentsResponse> CreateAssignmentsResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t free_variable_id = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CustomKeyValue>>> info = 0,
    flatbuffers::Offset<AssignedVariables> outgoing_assignments = 0,
    flatbuffers::Offset<FieldElementRepresentation> representation = 0,
    flatbuffers::Offset<flatbuffers::String> error = 0) {
  AssignmentsResponseBuilder builder_(_fbb);
  builder_.add_free_variable_id(free_variable_id);
  builder_.add_error(error);
  builder_.add_representation(representation);
  builder_.add_outgoing_assignments(outgoing_assignments);
  builder_.add_info(info);
  return builder_.Finish();
}

inline flatbuffers::Offset<AssignmentsResponse> CreateAssignmentsResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t free_variable_id = 0,
    const std::vector<flatbuffers::Offset<CustomKeyValue>> *info = nullptr,
    flatbuffers::Offset<AssignedVariables> outgoing_assignments = 0,
    flatbuffers::Offset<FieldElementRepresentation> representation = 0,
    const char *error = nullptr) {
  auto info__ = info ? _fbb.CreateVector<flatbuffers::Offset<CustomKeyValue>>(*info) : 0;
  auto error__ = error ? _fbb.CreateString(error) : 0;
  return Gadget::CreateAssignmentsResponse(
      _fbb,
      free_variable_id,
      info__,
      outgoing_assignments,
      representation,
      error__);
}

inline bool VerifyMessage(flatbuffers::Verifier &verifier, const void *obj, Message type) {
  switch (type) {
    case Message_NONE: {
      return true;
    }
    case Message_R1CSRequest: {
      auto ptr = reinterpret_cast<const R1CSRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_R1CSChunk: {
      auto ptr = reinterpret_cast<const R1CSChunk *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_R1CSResponse: {
      auto ptr = reinterpret_cast<const R1CSResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_AssignmentsRequest: {
      auto ptr = reinterpret_cast<const AssignmentsRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_AssignmentsChunk: {
      auto ptr = reinterpret_cast<const AssignmentsChunk *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_AssignmentsResponse: {
      auto ptr = reinterpret_cast<const AssignmentsResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyMessageVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyMessage(
        verifier,  values->Get(i), types->GetEnum<Message>(i))) {
      return false;
    }
  }
  return true;
}

inline const Gadget::Root *GetRoot(const void *buf) {
  return flatbuffers::GetRoot<Gadget::Root>(buf);
}

inline const Gadget::Root *GetSizePrefixedRoot(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<Gadget::Root>(buf);
}

inline bool VerifyRootBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Gadget::Root>(nullptr);
}

inline bool VerifySizePrefixedRootBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Gadget::Root>(nullptr);
}

inline void FinishRootBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<Gadget::Root> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedRootBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<Gadget::Root> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace Gadget

#endif  // FLATBUFFERS_GENERATED_GADGET_GADGET_H_
