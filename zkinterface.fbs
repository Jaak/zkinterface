// This is a FlatBuffers schema.
// See https://google.github.io/flatbuffers/

namespace zkinterface;

/// The messages that the caller and gadget can exchange.
union Message {
    GadgetCall,
    GadgetReturn,

    R1CSConstraints,
    AssignedVariables,

    Connection,
}

/// Caller calls a gadget.
table GadgetCall {
    /// Incoming Variables to use as connections to the gadget.
    /// Allocated by the caller.
    /// Includes the first free Variable ID; the gadget can allocate new IDs
    /// starting with `inputs.free_variable_id`.
    /// The same structure must be provided for R1CS and assignment generation.
    inputs              :Connection;

    /// Whether constraints should be generated.
    generate_r1cs       :bool;

    /// Whether an assignment should be generated.
    /// Provide witness values to the gadget.
    generate_assignment :bool;

    /// The order of the field used by the current system.
    /// A BigInt.
    field_order             :[ubyte];

    /// Optional: Any static parameter that may influence the instance
    /// construction. Parameters can be standard, conventional, or custom.
    /// Example: function_name, if a gadget supports multiple function variants.
    /// Example: the depth of a Merkle tree.
    /// Counter-example: a Merkle path is not configuration (rather witness).
    configuration           :[KeyValue];
}

/// The gadget returns to the caller. This is the final message
/// after all R1CSConstraints or AssignedVariables have been sent.
table GadgetReturn {
    /// Outgoing Variables to use as connections to the gadget.
    /// There may be no Outgoing Variables if the gadget is a pure assertion.
    /// Allocated by the gadget.
    /// Include the first variable ID free after the gadget call;
    /// `outputs.free_variable_id` is greater than all IDs allocated by the gadget.
    outputs :Connection;

    /// Optional: An error message. Null if no error.
    error   :string;
}

    /// A connection into a sub-circuits.
    table Connection {
        /// First variable ID free after this connection.
        /// A variable ID greater than all IDs allocated at the time.
        free_variable_id :uint64;

        /// Variables to use as connections to the sub-circuit.
        variable_ids  :[uint64];

        /// Optional: The values assigned to variables, if any.
        /// Contiguous BigInts in the same order as `variable_ids`.
        values      :[ubyte];

        /// Optional: Any info that may be useful to the recipient.
        /// Example: a Merkle authentication path.
        info                   :[KeyValue];
    }

    /// Generic key-value for custom attributes.
    table KeyValue {
        key   :string;
        value :[ubyte];
    }

/// Report constraints to be added to the constraints system.
/// To send to the stream of constraints.
table R1CSConstraints {
    constraints    :[BilinearConstraint];
}

    /// An R1CS constraint between variables.
    table BilinearConstraint {
        // (A) * (B) = (C)
        linear_combination_a :VariableValues;
        linear_combination_b :VariableValues;
        linear_combination_c :VariableValues;
    }

/// Report local assignments computed by the gadget.
/// To send to the stream of assigned variables.
/// Does not include input and output variables.
table AssignedVariables {
    values :VariableValues;
}

    /// Concrete variable values.
    /// Used for linear combinations and assignments.
    table VariableValues {
        /// The IDs of the variables being assigned to.
        variable_ids   :[uint64];

        /// Field Elements assigned to variables.
        /// Contiguous BigInts in the same order as variable_ids.
        ///
        /// The field in use is defined in `instance.field_order`.
        ///
        /// The size of an element representation is determined by:
        ///     element size = elements.length / variable_ids.length
        ///
        /// The element representation may be truncated and therefore shorter
        /// than the canonical representation. Truncated bytes are treated as zeros.
        values         :[ubyte];
    }

    // type Variable ID = uint64
    //
    // IDs must be unique within a constraint system.
    // Zero is a reserved special value.

    // type BigInt
    //
    // Big integers are represented as canonical little-endian byte arrays.
    // Multiple big integers can be concatenated in a single array.
    //
    // Evolution plan:
    // If a different representation of elements is to be supported in the future,
    // it should use new fields, and omit the current canonical fields.
    // This will allow past implementations to detect whether they are compatible.


// All message types are encapsulated in the FlatBuffers root table.
table Root {
    message :Message;
}
root_type Root;

// When storing messages to files, this extension and identifier should be used.
file_extension "zkif";
file_identifier "zkif"; // a.k.a. magic bytes.

// Message framing:
//
// All messages must be prefixed by the size of the message,
// not including the prefix, as a 4-bytes little-endian unsigned integer.
