// automatically generated by the FlatBuffers compiler, do not modify


pub mod gadget {
  #![allow(dead_code)]
  #![allow(unused_imports)]

  use std::mem;
  use std::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::EndianScalar;

#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Debug)]
pub enum Message {
  NONE = 0,
  R1CSRequest = 1,
  R1CSChunk = 2,
  R1CSResponse = 3,
  AssignmentsRequest = 4,
  AssignmentsChunk = 5,
  AssignmentsResponse = 6,

}

const ENUM_MIN_MESSAGE: u8 = 0;
const ENUM_MAX_MESSAGE: u8 = 6;

impl<'a> flatbuffers::Follow<'a> for Message {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for Message {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const Message;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const Message;
    unsafe { *p }
  }
}

impl flatbuffers::Push for Message {
    type Output = Message;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<Message>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_MESSAGE:[Message; 7] = [
  Message::NONE,
  Message::R1CSRequest,
  Message::R1CSChunk,
  Message::R1CSResponse,
  Message::AssignmentsRequest,
  Message::AssignmentsChunk,
  Message::AssignmentsResponse
];

#[allow(non_camel_case_types)]
const ENUM_NAMES_MESSAGE:[&'static str; 7] = [
    "NONE",
    "R1CSRequest",
    "R1CSChunk",
    "R1CSResponse",
    "AssignmentsRequest",
    "AssignmentsChunk",
    "AssignmentsResponse"
];

pub fn enum_name_message(e: Message) -> &'static str {
  let index: usize = e as usize;
  ENUM_NAMES_MESSAGE[index]
}

pub struct MessageUnionTableOffset {}
pub enum RootOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Root<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Root<'a> {
    type Inner = Root<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Root<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Root {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args RootArgs) -> flatbuffers::WIPOffset<Root<'bldr>> {
      let mut builder = RootBuilder::new(_fbb);
      if let Some(x) = args.message { builder.add_message(x); }
      builder.add_message_type(args.message_type);
      builder.finish()
    }

    pub const VT_MESSAGE_TYPE: flatbuffers::VOffsetT = 4;
    pub const VT_MESSAGE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn message_type(&self) -> Message {
    self._tab.get::<Message>(Root::VT_MESSAGE_TYPE, Some(Message::NONE)).unwrap()
  }
  #[inline]
  pub fn message(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Root::VT_MESSAGE, None)
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn message_as_r1csrequest(&'a self) -> Option<R1CSRequest> {
    if self.message_type() == Message::R1CSRequest {
      self.message().map(|u| R1CSRequest::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn message_as_r1cschunk(&'a self) -> Option<R1CSChunk> {
    if self.message_type() == Message::R1CSChunk {
      self.message().map(|u| R1CSChunk::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn message_as_r1csresponse(&'a self) -> Option<R1CSResponse> {
    if self.message_type() == Message::R1CSResponse {
      self.message().map(|u| R1CSResponse::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn message_as_assignments_request(&'a self) -> Option<AssignmentsRequest> {
    if self.message_type() == Message::AssignmentsRequest {
      self.message().map(|u| AssignmentsRequest::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn message_as_assignments_chunk(&'a self) -> Option<AssignmentsChunk> {
    if self.message_type() == Message::AssignmentsChunk {
      self.message().map(|u| AssignmentsChunk::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn message_as_assignments_response(&'a self) -> Option<AssignmentsResponse> {
    if self.message_type() == Message::AssignmentsResponse {
      self.message().map(|u| AssignmentsResponse::init_from_table(u))
    } else {
      None
    }
  }

}

pub struct RootArgs {
    pub message_type: Message,
    pub message: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for RootArgs {
    #[inline]
    fn default() -> Self {
        RootArgs {
            message_type: Message::NONE,
            message: None,
        }
    }
}
pub struct RootBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RootBuilder<'a, 'b> {
  #[inline]
  pub fn add_message_type(&mut self, message_type: Message) {
    self.fbb_.push_slot::<Message>(Root::VT_MESSAGE_TYPE, message_type, Message::NONE);
  }
  #[inline]
  pub fn add_message(&mut self, message: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Root::VT_MESSAGE, message);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RootBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RootBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Root<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

/// Description of the representation or encoding of field elements.
/// If omitted, use a default representation:
/// name = "little-endian"
/// size = 32 bytes
pub enum FieldElementRepresentationOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct FieldElementRepresentation<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FieldElementRepresentation<'a> {
    type Inner = FieldElementRepresentation<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> FieldElementRepresentation<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FieldElementRepresentation {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args FieldElementRepresentationArgs<'args>) -> flatbuffers::WIPOffset<FieldElementRepresentation<'bldr>> {
      let mut builder = FieldElementRepresentationBuilder::new(_fbb);
      builder.add_size_(args.size_);
      if let Some(x) = args.name { builder.add_name(x); }
      builder.finish()
    }

    pub const VT_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_SIZE_: flatbuffers::VOffsetT = 6;

  /// The well-known name of the representation.
  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FieldElementRepresentation::VT_NAME, None)
  }
  /// The size of the representation of an element in bytes.
  #[inline]
  pub fn size_(&self) -> u32 {
    self._tab.get::<u32>(FieldElementRepresentation::VT_SIZE_, Some(0)).unwrap()
  }
}

pub struct FieldElementRepresentationArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub size_: u32,
}
impl<'a> Default for FieldElementRepresentationArgs<'a> {
    #[inline]
    fn default() -> Self {
        FieldElementRepresentationArgs {
            name: None,
            size_: 0,
        }
    }
}
pub struct FieldElementRepresentationBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FieldElementRepresentationBuilder<'a, 'b> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FieldElementRepresentation::VT_NAME, name);
  }
  #[inline]
  pub fn add_size_(&mut self, size_: u32) {
    self.fbb_.push_slot::<u32>(FieldElementRepresentation::VT_SIZE_, size_, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FieldElementRepresentationBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FieldElementRepresentationBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FieldElementRepresentation<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

/// Terms in a R1CS vector.
pub enum TermsOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Terms<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Terms<'a> {
    type Inner = Terms<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Terms<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Terms {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args TermsArgs<'args>) -> flatbuffers::WIPOffset<Terms<'bldr>> {
      let mut builder = TermsBuilder::new(_fbb);
      if let Some(x) = args.coefficients { builder.add_coefficients(x); }
      if let Some(x) = args.variable_ids { builder.add_variable_ids(x); }
      builder.finish()
    }

    pub const VT_VARIABLE_IDS: flatbuffers::VOffsetT = 4;
    pub const VT_COEFFICIENTS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn variable_ids(&self) -> Option<flatbuffers::Vector<'a, u64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u64>>>(Terms::VT_VARIABLE_IDS, None)
  }
  /// Contiguous coefficient representations in the same order as variable_ids.
  #[inline]
  pub fn coefficients(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Terms::VT_COEFFICIENTS, None).map(|v| v.safe_slice())
  }
}

pub struct TermsArgs<'a> {
    pub variable_ids: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u64>>>,
    pub coefficients: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
}
impl<'a> Default for TermsArgs<'a> {
    #[inline]
    fn default() -> Self {
        TermsArgs {
            variable_ids: None,
            coefficients: None,
        }
    }
}
pub struct TermsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TermsBuilder<'a, 'b> {
  #[inline]
  pub fn add_variable_ids(&mut self, variable_ids: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Terms::VT_VARIABLE_IDS, variable_ids);
  }
  #[inline]
  pub fn add_coefficients(&mut self, coefficients: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Terms::VT_COEFFICIENTS, coefficients);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TermsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    TermsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Terms<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

/// A low-level R1CS constraint between variables.
/// Targets the generic mechanisms that build circuits.
/// Intended to be sent in sequences.
pub enum ConstraintOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Constraint<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Constraint<'a> {
    type Inner = Constraint<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Constraint<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Constraint {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ConstraintArgs<'args>) -> flatbuffers::WIPOffset<Constraint<'bldr>> {
      let mut builder = ConstraintBuilder::new(_fbb);
      if let Some(x) = args.c { builder.add_c(x); }
      if let Some(x) = args.b { builder.add_b(x); }
      if let Some(x) = args.a { builder.add_a(x); }
      builder.finish()
    }

    pub const VT_A: flatbuffers::VOffsetT = 4;
    pub const VT_B: flatbuffers::VOffsetT = 6;
    pub const VT_C: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn a(&self) -> Option<Terms<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Terms<'a>>>(Constraint::VT_A, None)
  }
  #[inline]
  pub fn b(&self) -> Option<Terms<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Terms<'a>>>(Constraint::VT_B, None)
  }
  #[inline]
  pub fn c(&self) -> Option<Terms<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Terms<'a>>>(Constraint::VT_C, None)
  }
}

pub struct ConstraintArgs<'a> {
    pub a: Option<flatbuffers::WIPOffset<Terms<'a >>>,
    pub b: Option<flatbuffers::WIPOffset<Terms<'a >>>,
    pub c: Option<flatbuffers::WIPOffset<Terms<'a >>>,
}
impl<'a> Default for ConstraintArgs<'a> {
    #[inline]
    fn default() -> Self {
        ConstraintArgs {
            a: None,
            b: None,
            c: None,
        }
    }
}
pub struct ConstraintBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ConstraintBuilder<'a, 'b> {
  #[inline]
  pub fn add_a(&mut self, a: flatbuffers::WIPOffset<Terms<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Terms>>(Constraint::VT_A, a);
  }
  #[inline]
  pub fn add_b(&mut self, b: flatbuffers::WIPOffset<Terms<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Terms>>(Constraint::VT_B, b);
  }
  #[inline]
  pub fn add_c(&mut self, c: flatbuffers::WIPOffset<Terms<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Terms>>(Constraint::VT_C, c);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ConstraintBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ConstraintBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Constraint<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

/// Low-level assignments to variables.
/// Targets the generic mechanisms that prepare proofs.
pub enum AssignedVariablesOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct AssignedVariables<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AssignedVariables<'a> {
    type Inner = AssignedVariables<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> AssignedVariables<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        AssignedVariables {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args AssignedVariablesArgs<'args>) -> flatbuffers::WIPOffset<AssignedVariables<'bldr>> {
      let mut builder = AssignedVariablesBuilder::new(_fbb);
      if let Some(x) = args.elements { builder.add_elements(x); }
      if let Some(x) = args.variable_ids { builder.add_variable_ids(x); }
      builder.finish()
    }

    pub const VT_VARIABLE_IDS: flatbuffers::VOffsetT = 4;
    pub const VT_ELEMENTS: flatbuffers::VOffsetT = 6;

  /// The IDs of the variables being assigned to.
  #[inline]
  pub fn variable_ids(&self) -> Option<flatbuffers::Vector<'a, u64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u64>>>(AssignedVariables::VT_VARIABLE_IDS, None)
  }
  /// Contiguous element representations in the same order as variable_ids.
  #[inline]
  pub fn elements(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(AssignedVariables::VT_ELEMENTS, None).map(|v| v.safe_slice())
  }
}

pub struct AssignedVariablesArgs<'a> {
    pub variable_ids: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u64>>>,
    pub elements: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
}
impl<'a> Default for AssignedVariablesArgs<'a> {
    #[inline]
    fn default() -> Self {
        AssignedVariablesArgs {
            variable_ids: None,
            elements: None,
        }
    }
}
pub struct AssignedVariablesBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> AssignedVariablesBuilder<'a, 'b> {
  #[inline]
  pub fn add_variable_ids(&mut self, variable_ids: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AssignedVariables::VT_VARIABLE_IDS, variable_ids);
  }
  #[inline]
  pub fn add_elements(&mut self, elements: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AssignedVariables::VT_ELEMENTS, elements);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> AssignedVariablesBuilder<'a, 'b> {
    let start = _fbb.start_table();
    AssignedVariablesBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<AssignedVariables<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

/// Generic key-value for miscellaneous attributes.
pub enum CustomKeyValueOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct CustomKeyValue<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CustomKeyValue<'a> {
    type Inner = CustomKeyValue<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> CustomKeyValue<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        CustomKeyValue {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args CustomKeyValueArgs<'args>) -> flatbuffers::WIPOffset<CustomKeyValue<'bldr>> {
      let mut builder = CustomKeyValueBuilder::new(_fbb);
      if let Some(x) = args.value { builder.add_value(x); }
      if let Some(x) = args.key { builder.add_key(x); }
      builder.finish()
    }

    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn key(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CustomKeyValue::VT_KEY, None)
  }
  #[inline]
  pub fn value(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(CustomKeyValue::VT_VALUE, None).map(|v| v.safe_slice())
  }
}

pub struct CustomKeyValueArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub value: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
}
impl<'a> Default for CustomKeyValueArgs<'a> {
    #[inline]
    fn default() -> Self {
        CustomKeyValueArgs {
            key: None,
            value: None,
        }
    }
}
pub struct CustomKeyValueBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> CustomKeyValueBuilder<'a, 'b> {
  #[inline]
  pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CustomKeyValue::VT_KEY, key);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CustomKeyValue::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> CustomKeyValueBuilder<'a, 'b> {
    let start = _fbb.start_table();
    CustomKeyValueBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CustomKeyValue<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

/// A high-level structure of variables.
/// Define the interface between a gadget and the rest of the circuit.
/// In gadget composition, the parent provides these structures to its child.
/// A gadget should document what structures it can accept.
pub enum StructuredConnectionOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct StructuredConnection<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for StructuredConnection<'a> {
    type Inner = StructuredConnection<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> StructuredConnection<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        StructuredConnection {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args StructuredConnectionArgs<'args>) -> flatbuffers::WIPOffset<StructuredConnection<'bldr>> {
      let mut builder = StructuredConnectionBuilder::new(_fbb);
      if let Some(x) = args.info { builder.add_info(x); }
      if let Some(x) = args.name { builder.add_name(x); }
      if let Some(x) = args.structures { builder.add_structures(x); }
      if let Some(x) = args.variable_ids { builder.add_variable_ids(x); }
      builder.finish()
    }

    pub const VT_VARIABLE_IDS: flatbuffers::VOffsetT = 4;
    pub const VT_STRUCTURES: flatbuffers::VOffsetT = 6;
    pub const VT_NAME: flatbuffers::VOffsetT = 8;
    pub const VT_INFO: flatbuffers::VOffsetT = 10;

  /// Variables allocated by the caller to use as connections to the gadget.
  #[inline]
  pub fn variable_ids(&self) -> Option<flatbuffers::Vector<'a, u64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u64>>>(StructuredConnection::VT_VARIABLE_IDS, None)
  }
  /// Optionally recursive type.
  /// If used, the field `variable_ids` must be null.
  #[inline]
  pub fn structures(&self) -> Option<flatbuffers::Vector<flatbuffers::ForwardsUOffset<StructuredConnection<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<StructuredConnection<'a>>>>>(StructuredConnection::VT_STRUCTURES, None)
  }
  /// Name of the connection.
  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(StructuredConnection::VT_NAME, None)
  }
  /// Any custom information.
  #[inline]
  pub fn info(&self) -> Option<flatbuffers::Vector<flatbuffers::ForwardsUOffset<CustomKeyValue<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<CustomKeyValue<'a>>>>>(StructuredConnection::VT_INFO, None)
  }
}

pub struct StructuredConnectionArgs<'a> {
    pub variable_ids: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u64>>>,
    pub structures: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<StructuredConnection<'a >>>>>,
    pub name: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub info: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<CustomKeyValue<'a >>>>>,
}
impl<'a> Default for StructuredConnectionArgs<'a> {
    #[inline]
    fn default() -> Self {
        StructuredConnectionArgs {
            variable_ids: None,
            structures: None,
            name: None,
            info: None,
        }
    }
}
pub struct StructuredConnectionBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> StructuredConnectionBuilder<'a, 'b> {
  #[inline]
  pub fn add_variable_ids(&mut self, variable_ids: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StructuredConnection::VT_VARIABLE_IDS, variable_ids);
  }
  #[inline]
  pub fn add_structures(&mut self, structures: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<StructuredConnection<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StructuredConnection::VT_STRUCTURES, structures);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StructuredConnection::VT_NAME, name);
  }
  #[inline]
  pub fn add_info(&mut self, info: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<CustomKeyValue<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StructuredConnection::VT_INFO, info);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> StructuredConnectionBuilder<'a, 'b> {
    let start = _fbb.start_table();
    StructuredConnectionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<StructuredConnection<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

/// An instance of a gadget as part of a circuit.
pub enum GadgetInstanceOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct GadgetInstance<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GadgetInstance<'a> {
    type Inner = GadgetInstance<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> GadgetInstance<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GadgetInstance {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GadgetInstanceArgs<'args>) -> flatbuffers::WIPOffset<GadgetInstance<'bldr>> {
      let mut builder = GadgetInstanceBuilder::new(_fbb);
      builder.add_free_variable_id(args.free_variable_id);
      if let Some(x) = args.outgoing_connections { builder.add_outgoing_connections(x); }
      if let Some(x) = args.incoming_connections { builder.add_incoming_connections(x); }
      if let Some(x) = args.parameters { builder.add_parameters(x); }
      if let Some(x) = args.gadget_name { builder.add_gadget_name(x); }
      builder.finish()
    }

    pub const VT_GADGET_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_PARAMETERS: flatbuffers::VOffsetT = 6;
    pub const VT_INCOMING_CONNECTIONS: flatbuffers::VOffsetT = 8;
    pub const VT_OUTGOING_CONNECTIONS: flatbuffers::VOffsetT = 10;
    pub const VT_FREE_VARIABLE_ID: flatbuffers::VOffsetT = 12;

  /// Which gadget to instantiate.
  /// Allows a library to provide multiple gadgets.
  #[inline]
  pub fn gadget_name(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GadgetInstance::VT_GADGET_NAME, None)
  }
  /// Any parameter that may influence the instance behavior.
  /// Parameters can be standard, conventional, or specific to a gadget.
  #[inline]
  pub fn parameters(&self) -> Option<flatbuffers::Vector<flatbuffers::ForwardsUOffset<CustomKeyValue<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<CustomKeyValue<'a>>>>>(GadgetInstance::VT_PARAMETERS, None)
  }
  /// Structure of variables that must be assigned by the calling parent.
  #[inline]
  pub fn incoming_connections(&self) -> Option<StructuredConnection<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<StructuredConnection<'a>>>(GadgetInstance::VT_INCOMING_CONNECTIONS, None)
  }
  /// Structure of variables that must be assigned by the called gadget.
  /// There may be no outgoing variables if the gadget represents a pure assertion.
  #[inline]
  pub fn outgoing_connections(&self) -> Option<StructuredConnection<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<StructuredConnection<'a>>>(GadgetInstance::VT_OUTGOING_CONNECTIONS, None)
  }
  /// First free variable ID. The instance can allocate IDs greater or equal.
  #[inline]
  pub fn free_variable_id(&self) -> u64 {
    self._tab.get::<u64>(GadgetInstance::VT_FREE_VARIABLE_ID, Some(0)).unwrap()
  }
}

pub struct GadgetInstanceArgs<'a> {
    pub gadget_name: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub parameters: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<CustomKeyValue<'a >>>>>,
    pub incoming_connections: Option<flatbuffers::WIPOffset<StructuredConnection<'a >>>,
    pub outgoing_connections: Option<flatbuffers::WIPOffset<StructuredConnection<'a >>>,
    pub free_variable_id: u64,
}
impl<'a> Default for GadgetInstanceArgs<'a> {
    #[inline]
    fn default() -> Self {
        GadgetInstanceArgs {
            gadget_name: None,
            parameters: None,
            incoming_connections: None,
            outgoing_connections: None,
            free_variable_id: 0,
        }
    }
}
pub struct GadgetInstanceBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GadgetInstanceBuilder<'a, 'b> {
  #[inline]
  pub fn add_gadget_name(&mut self, gadget_name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GadgetInstance::VT_GADGET_NAME, gadget_name);
  }
  #[inline]
  pub fn add_parameters(&mut self, parameters: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<CustomKeyValue<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GadgetInstance::VT_PARAMETERS, parameters);
  }
  #[inline]
  pub fn add_incoming_connections(&mut self, incoming_connections: flatbuffers::WIPOffset<StructuredConnection<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<StructuredConnection>>(GadgetInstance::VT_INCOMING_CONNECTIONS, incoming_connections);
  }
  #[inline]
  pub fn add_outgoing_connections(&mut self, outgoing_connections: flatbuffers::WIPOffset<StructuredConnection<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<StructuredConnection>>(GadgetInstance::VT_OUTGOING_CONNECTIONS, outgoing_connections);
  }
  #[inline]
  pub fn add_free_variable_id(&mut self, free_variable_id: u64) {
    self.fbb_.push_slot::<u64>(GadgetInstance::VT_FREE_VARIABLE_ID, free_variable_id, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GadgetInstanceBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GadgetInstanceBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GadgetInstance<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

/// Request to build an instance.
pub enum R1CSRequestOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct R1CSRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for R1CSRequest<'a> {
    type Inner = R1CSRequest<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> R1CSRequest<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        R1CSRequest {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args R1CSRequestArgs<'args>) -> flatbuffers::WIPOffset<R1CSRequest<'bldr>> {
      let mut builder = R1CSRequestBuilder::new(_fbb);
      if let Some(x) = args.instance { builder.add_instance(x); }
      builder.finish()
    }

    pub const VT_INSTANCE: flatbuffers::VOffsetT = 4;

  /// All details necessary to construct the instance.
  /// The same instance parameter must be provided in the corresponding AssignmentsRequest.
  #[inline]
  pub fn instance(&self) -> Option<GadgetInstance<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<GadgetInstance<'a>>>(R1CSRequest::VT_INSTANCE, None)
  }
}

pub struct R1CSRequestArgs<'a> {
    pub instance: Option<flatbuffers::WIPOffset<GadgetInstance<'a >>>,
}
impl<'a> Default for R1CSRequestArgs<'a> {
    #[inline]
    fn default() -> Self {
        R1CSRequestArgs {
            instance: None,
        }
    }
}
pub struct R1CSRequestBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> R1CSRequestBuilder<'a, 'b> {
  #[inline]
  pub fn add_instance(&mut self, instance: flatbuffers::WIPOffset<GadgetInstance<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<GadgetInstance>>(R1CSRequest::VT_INSTANCE, instance);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> R1CSRequestBuilder<'a, 'b> {
    let start = _fbb.start_table();
    R1CSRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<R1CSRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

/// Report all constraints in one or more chunks.
pub enum R1CSChunkOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct R1CSChunk<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for R1CSChunk<'a> {
    type Inner = R1CSChunk<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> R1CSChunk<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        R1CSChunk {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args R1CSChunkArgs<'args>) -> flatbuffers::WIPOffset<R1CSChunk<'bldr>> {
      let mut builder = R1CSChunkBuilder::new(_fbb);
      if let Some(x) = args.representation { builder.add_representation(x); }
      if let Some(x) = args.constraints { builder.add_constraints(x); }
      builder.finish()
    }

    pub const VT_CONSTRAINTS: flatbuffers::VOffsetT = 4;
    pub const VT_REPRESENTATION: flatbuffers::VOffsetT = 6;

  /// Constraints to add.
  #[inline]
  pub fn constraints(&self) -> Option<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Constraint<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Constraint<'a>>>>>(R1CSChunk::VT_CONSTRAINTS, None)
  }
  /// The representation used for the constraints.
  #[inline]
  pub fn representation(&self) -> Option<FieldElementRepresentation<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<FieldElementRepresentation<'a>>>(R1CSChunk::VT_REPRESENTATION, None)
  }
}

pub struct R1CSChunkArgs<'a> {
    pub constraints: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<Constraint<'a >>>>>,
    pub representation: Option<flatbuffers::WIPOffset<FieldElementRepresentation<'a >>>,
}
impl<'a> Default for R1CSChunkArgs<'a> {
    #[inline]
    fn default() -> Self {
        R1CSChunkArgs {
            constraints: None,
            representation: None,
        }
    }
}
pub struct R1CSChunkBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> R1CSChunkBuilder<'a, 'b> {
  #[inline]
  pub fn add_constraints(&mut self, constraints: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Constraint<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(R1CSChunk::VT_CONSTRAINTS, constraints);
  }
  #[inline]
  pub fn add_representation(&mut self, representation: flatbuffers::WIPOffset<FieldElementRepresentation<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<FieldElementRepresentation>>(R1CSChunk::VT_REPRESENTATION, representation);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> R1CSChunkBuilder<'a, 'b> {
    let start = _fbb.start_table();
    R1CSChunkBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<R1CSChunk<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

/// Response after the instantiation is complete.
pub enum R1CSResponseOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct R1CSResponse<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for R1CSResponse<'a> {
    type Inner = R1CSResponse<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> R1CSResponse<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        R1CSResponse {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args R1CSResponseArgs<'args>) -> flatbuffers::WIPOffset<R1CSResponse<'bldr>> {
      let mut builder = R1CSResponseBuilder::new(_fbb);
      builder.add_free_variable_id(args.free_variable_id);
      if let Some(x) = args.error { builder.add_error(x); }
      if let Some(x) = args.info { builder.add_info(x); }
      builder.finish()
    }

    pub const VT_FREE_VARIABLE_ID: flatbuffers::VOffsetT = 4;
    pub const VT_INFO: flatbuffers::VOffsetT = 6;
    pub const VT_ERROR: flatbuffers::VOffsetT = 8;

  /// A variable ID greater than all IDs allocated by the instance.
  #[inline]
  pub fn free_variable_id(&self) -> u64 {
    self._tab.get::<u64>(R1CSResponse::VT_FREE_VARIABLE_ID, Some(0)).unwrap()
  }
  /// Any info that may be useful to the calling parent.
  #[inline]
  pub fn info(&self) -> Option<flatbuffers::Vector<flatbuffers::ForwardsUOffset<CustomKeyValue<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<CustomKeyValue<'a>>>>>(R1CSResponse::VT_INFO, None)
  }
  /// An error message. Null if no error.
  #[inline]
  pub fn error(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(R1CSResponse::VT_ERROR, None)
  }
}

pub struct R1CSResponseArgs<'a> {
    pub free_variable_id: u64,
    pub info: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<CustomKeyValue<'a >>>>>,
    pub error: Option<flatbuffers::WIPOffset<&'a  str>>,
}
impl<'a> Default for R1CSResponseArgs<'a> {
    #[inline]
    fn default() -> Self {
        R1CSResponseArgs {
            free_variable_id: 0,
            info: None,
            error: None,
        }
    }
}
pub struct R1CSResponseBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> R1CSResponseBuilder<'a, 'b> {
  #[inline]
  pub fn add_free_variable_id(&mut self, free_variable_id: u64) {
    self.fbb_.push_slot::<u64>(R1CSResponse::VT_FREE_VARIABLE_ID, free_variable_id, 0);
  }
  #[inline]
  pub fn add_info(&mut self, info: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<CustomKeyValue<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(R1CSResponse::VT_INFO, info);
  }
  #[inline]
  pub fn add_error(&mut self, error: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(R1CSResponse::VT_ERROR, error);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> R1CSResponseBuilder<'a, 'b> {
    let start = _fbb.start_table();
    R1CSResponseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<R1CSResponse<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

/// Request assignments computed from a witness.
pub enum AssignmentsRequestOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct AssignmentsRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AssignmentsRequest<'a> {
    type Inner = AssignmentsRequest<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> AssignmentsRequest<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        AssignmentsRequest {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args AssignmentsRequestArgs<'args>) -> flatbuffers::WIPOffset<AssignmentsRequest<'bldr>> {
      let mut builder = AssignmentsRequestBuilder::new(_fbb);
      if let Some(x) = args.representation { builder.add_representation(x); }
      if let Some(x) = args.incoming_assignments { builder.add_incoming_assignments(x); }
      if let Some(x) = args.witness { builder.add_witness(x); }
      if let Some(x) = args.instance { builder.add_instance(x); }
      builder.finish()
    }

    pub const VT_INSTANCE: flatbuffers::VOffsetT = 4;
    pub const VT_WITNESS: flatbuffers::VOffsetT = 6;
    pub const VT_INCOMING_ASSIGNMENTS: flatbuffers::VOffsetT = 8;
    pub const VT_REPRESENTATION: flatbuffers::VOffsetT = 10;

  /// All details necessary to construct the instance.
  /// The same instance parameter must be provided as in the corresponding R1CSRequest.
  #[inline]
  pub fn instance(&self) -> Option<GadgetInstance<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<GadgetInstance<'a>>>(AssignmentsRequest::VT_INSTANCE, None)
  }
  /// Any info that may be useful to the gadget to compute its assignments.
  #[inline]
  pub fn witness(&self) -> Option<flatbuffers::Vector<flatbuffers::ForwardsUOffset<CustomKeyValue<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<CustomKeyValue<'a>>>>>(AssignmentsRequest::VT_WITNESS, None)
  }
  /// The values that the parent assigned to `instance.incomingConnections`.
  #[inline]
  pub fn incoming_assignments(&self) -> Option<AssignedVariables<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<AssignedVariables<'a>>>(AssignmentsRequest::VT_INCOMING_ASSIGNMENTS, None)
  }
  /// The representation used for the incomingAssignments.
  #[inline]
  pub fn representation(&self) -> Option<FieldElementRepresentation<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<FieldElementRepresentation<'a>>>(AssignmentsRequest::VT_REPRESENTATION, None)
  }
}

pub struct AssignmentsRequestArgs<'a> {
    pub instance: Option<flatbuffers::WIPOffset<GadgetInstance<'a >>>,
    pub witness: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<CustomKeyValue<'a >>>>>,
    pub incoming_assignments: Option<flatbuffers::WIPOffset<AssignedVariables<'a >>>,
    pub representation: Option<flatbuffers::WIPOffset<FieldElementRepresentation<'a >>>,
}
impl<'a> Default for AssignmentsRequestArgs<'a> {
    #[inline]
    fn default() -> Self {
        AssignmentsRequestArgs {
            instance: None,
            witness: None,
            incoming_assignments: None,
            representation: None,
        }
    }
}
pub struct AssignmentsRequestBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> AssignmentsRequestBuilder<'a, 'b> {
  #[inline]
  pub fn add_instance(&mut self, instance: flatbuffers::WIPOffset<GadgetInstance<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<GadgetInstance>>(AssignmentsRequest::VT_INSTANCE, instance);
  }
  #[inline]
  pub fn add_witness(&mut self, witness: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<CustomKeyValue<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AssignmentsRequest::VT_WITNESS, witness);
  }
  #[inline]
  pub fn add_incoming_assignments(&mut self, incoming_assignments: flatbuffers::WIPOffset<AssignedVariables<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<AssignedVariables>>(AssignmentsRequest::VT_INCOMING_ASSIGNMENTS, incoming_assignments);
  }
  #[inline]
  pub fn add_representation(&mut self, representation: flatbuffers::WIPOffset<FieldElementRepresentation<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<FieldElementRepresentation>>(AssignmentsRequest::VT_REPRESENTATION, representation);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> AssignmentsRequestBuilder<'a, 'b> {
    let start = _fbb.start_table();
    AssignmentsRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<AssignmentsRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

/// Report local and outgoing assignments in one or more chunks.
pub enum AssignmentsChunkOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct AssignmentsChunk<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AssignmentsChunk<'a> {
    type Inner = AssignmentsChunk<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> AssignmentsChunk<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        AssignmentsChunk {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args AssignmentsChunkArgs<'args>) -> flatbuffers::WIPOffset<AssignmentsChunk<'bldr>> {
      let mut builder = AssignmentsChunkBuilder::new(_fbb);
      if let Some(x) = args.representation { builder.add_representation(x); }
      if let Some(x) = args.assigned_variables { builder.add_assigned_variables(x); }
      builder.finish()
    }

    pub const VT_ASSIGNED_VARIABLES: flatbuffers::VOffsetT = 4;
    pub const VT_REPRESENTATION: flatbuffers::VOffsetT = 6;

  /// Assignments computed by the gadgets.
  #[inline]
  pub fn assigned_variables(&self) -> Option<AssignedVariables<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<AssignedVariables<'a>>>(AssignmentsChunk::VT_ASSIGNED_VARIABLES, None)
  }
  /// The representation used for the assignments.
  #[inline]
  pub fn representation(&self) -> Option<FieldElementRepresentation<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<FieldElementRepresentation<'a>>>(AssignmentsChunk::VT_REPRESENTATION, None)
  }
}

pub struct AssignmentsChunkArgs<'a> {
    pub assigned_variables: Option<flatbuffers::WIPOffset<AssignedVariables<'a >>>,
    pub representation: Option<flatbuffers::WIPOffset<FieldElementRepresentation<'a >>>,
}
impl<'a> Default for AssignmentsChunkArgs<'a> {
    #[inline]
    fn default() -> Self {
        AssignmentsChunkArgs {
            assigned_variables: None,
            representation: None,
        }
    }
}
pub struct AssignmentsChunkBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> AssignmentsChunkBuilder<'a, 'b> {
  #[inline]
  pub fn add_assigned_variables(&mut self, assigned_variables: flatbuffers::WIPOffset<AssignedVariables<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<AssignedVariables>>(AssignmentsChunk::VT_ASSIGNED_VARIABLES, assigned_variables);
  }
  #[inline]
  pub fn add_representation(&mut self, representation: flatbuffers::WIPOffset<FieldElementRepresentation<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<FieldElementRepresentation>>(AssignmentsChunk::VT_REPRESENTATION, representation);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> AssignmentsChunkBuilder<'a, 'b> {
    let start = _fbb.start_table();
    AssignmentsChunkBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<AssignmentsChunk<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

/// Response after all assignments have been reported.
pub enum AssignmentsResponseOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct AssignmentsResponse<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AssignmentsResponse<'a> {
    type Inner = AssignmentsResponse<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> AssignmentsResponse<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        AssignmentsResponse {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args AssignmentsResponseArgs<'args>) -> flatbuffers::WIPOffset<AssignmentsResponse<'bldr>> {
      let mut builder = AssignmentsResponseBuilder::new(_fbb);
      builder.add_free_variable_id(args.free_variable_id);
      if let Some(x) = args.error { builder.add_error(x); }
      if let Some(x) = args.representation { builder.add_representation(x); }
      if let Some(x) = args.outgoing_assignments { builder.add_outgoing_assignments(x); }
      if let Some(x) = args.info { builder.add_info(x); }
      builder.finish()
    }

    pub const VT_FREE_VARIABLE_ID: flatbuffers::VOffsetT = 4;
    pub const VT_INFO: flatbuffers::VOffsetT = 6;
    pub const VT_OUTGOING_ASSIGNMENTS: flatbuffers::VOffsetT = 8;
    pub const VT_REPRESENTATION: flatbuffers::VOffsetT = 10;
    pub const VT_ERROR: flatbuffers::VOffsetT = 12;

  /// A variable ID greater than all IDs allocated by the instance.
  #[inline]
  pub fn free_variable_id(&self) -> u64 {
    self._tab.get::<u64>(AssignmentsResponse::VT_FREE_VARIABLE_ID, Some(0)).unwrap()
  }
  /// Any info that may be useful to the calling parent.
  #[inline]
  pub fn info(&self) -> Option<flatbuffers::Vector<flatbuffers::ForwardsUOffset<CustomKeyValue<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<CustomKeyValue<'a>>>>>(AssignmentsResponse::VT_INFO, None)
  }
  /// The values that the gadget assigned to `instance.outgoingConnections`.
  /// Intentionally redundant with AssignmentsChunk to allow handling
  /// the outgoing variables separately from the bulk of local variables assignments.
  #[inline]
  pub fn outgoing_assignments(&self) -> Option<AssignedVariables<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<AssignedVariables<'a>>>(AssignmentsResponse::VT_OUTGOING_ASSIGNMENTS, None)
  }
  /// The representation used for the outgoingAssignments.
  #[inline]
  pub fn representation(&self) -> Option<FieldElementRepresentation<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<FieldElementRepresentation<'a>>>(AssignmentsResponse::VT_REPRESENTATION, None)
  }
  /// An error message. Null if no error.
  #[inline]
  pub fn error(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AssignmentsResponse::VT_ERROR, None)
  }
}

pub struct AssignmentsResponseArgs<'a> {
    pub free_variable_id: u64,
    pub info: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<CustomKeyValue<'a >>>>>,
    pub outgoing_assignments: Option<flatbuffers::WIPOffset<AssignedVariables<'a >>>,
    pub representation: Option<flatbuffers::WIPOffset<FieldElementRepresentation<'a >>>,
    pub error: Option<flatbuffers::WIPOffset<&'a  str>>,
}
impl<'a> Default for AssignmentsResponseArgs<'a> {
    #[inline]
    fn default() -> Self {
        AssignmentsResponseArgs {
            free_variable_id: 0,
            info: None,
            outgoing_assignments: None,
            representation: None,
            error: None,
        }
    }
}
pub struct AssignmentsResponseBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> AssignmentsResponseBuilder<'a, 'b> {
  #[inline]
  pub fn add_free_variable_id(&mut self, free_variable_id: u64) {
    self.fbb_.push_slot::<u64>(AssignmentsResponse::VT_FREE_VARIABLE_ID, free_variable_id, 0);
  }
  #[inline]
  pub fn add_info(&mut self, info: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<CustomKeyValue<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AssignmentsResponse::VT_INFO, info);
  }
  #[inline]
  pub fn add_outgoing_assignments(&mut self, outgoing_assignments: flatbuffers::WIPOffset<AssignedVariables<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<AssignedVariables>>(AssignmentsResponse::VT_OUTGOING_ASSIGNMENTS, outgoing_assignments);
  }
  #[inline]
  pub fn add_representation(&mut self, representation: flatbuffers::WIPOffset<FieldElementRepresentation<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<FieldElementRepresentation>>(AssignmentsResponse::VT_REPRESENTATION, representation);
  }
  #[inline]
  pub fn add_error(&mut self, error: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AssignmentsResponse::VT_ERROR, error);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> AssignmentsResponseBuilder<'a, 'b> {
    let start = _fbb.start_table();
    AssignmentsResponseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<AssignmentsResponse<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

#[inline]
pub fn get_root_as_root<'a>(buf: &'a [u8]) -> Root<'a> {
  flatbuffers::get_root::<Root<'a>>(buf)
}

#[inline]
pub fn get_size_prefixed_root_as_root<'a>(buf: &'a [u8]) -> Root<'a> {
  flatbuffers::get_size_prefixed_root::<Root<'a>>(buf)
}

#[inline]
pub fn finish_root_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<Root<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_root_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<Root<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
}  // pub mod Gadget

