namespace Gadget;

union Message {
    GadgetsDescriptionRequest,
    GadgetsDescriptionResponse,

    R1CSRequest,
    R1CSConstraints,
    R1CSResponse,

    AssignmentsRequest,
    AssignedVariables,
    AssignmentsResponse,
}

table Root {
    message :Message;
}

root_type Root;


// == Types ==

// Variable ID = uint64
// Unique within a constraint system.
// Zero is a reserved special value.

/// The terms in a R1CS linear combination.
table LinearCombination {
    // The IDs of the variables to constrain.
    variable_ids :[uint64];

    /// Contiguous constant coefficient representations in the same order as variable_ids.
    coefficients :[ubyte];
}

/// A low-level R1CS constraint between variables.
/// Targets the generic mechanisms that build circuits.
/// Intended to be sent in sequences.
table Constraint {
    // (A) * (B) = (C)
    a :LinearCombination;
    b :LinearCombination;
    c :LinearCombination;
}

/// An instance of a gadget as part of a circuit.
table GadgetInstance {
    /// Which gadget to instantiate.
    /// Allows a library to provide multiple gadgets.
    gadget_name             :string;

    /// Variables allocated by the caller to use as connections to the gadget.
    /// Incoming variables are assigned by the calling parent.
    incoming_variable_ids   :[uint64];

    /// Variables allocated by the caller to use as connections to the gadget.
    /// Outgoing variables are assigned by the called gadget.
    /// There may be no outgoing variables if the gadget represents a pure assertion.
    outgoing_variable_ids   :[uint64];

    /// First free variable ID before the call.
    /// The gadget can allocate IDs greater or equal.
    free_variable_id_before :uint64;

    /// Optional: Any parameter that may influence the instance behavior.
    /// Parameters can be standard, conventional, or specific to a gadget.
    parameters              :[CustomKeyValue];
}


// == Messages for Instantiation ==

/// Request to build an instance.
table R1CSRequest {
    /// All details necessary to construct the instance.
    /// The same instance parameter must be provided in the corresponding AssignmentsRequest.
    instance :GadgetInstance;
}

/// Report constraints to be added to the constraints system.
/// To send to the stream of constraints.
table R1CSConstraints {
    constraints    :[Constraint];

    /// Optional: The representation used for the constraint coefficients, if non-default.
    representation :FieldElementRepresentation;
}

/// Response after all R1CSConstraints have been sent.
table R1CSResponse {
    /// First variable ID free after the gadget call.
    /// A variable ID greater than all IDs allocated by the gadget.
    free_variable_id_after :uint64;

    /// Optional: Any info that may be useful to the calling parent.
    info                   :[CustomKeyValue];

    /// Optional: An error message. Null if no error.
    error                  :string;
}


// == Messages for Proving ==

/// Request assignments computed from a witness.
table AssignmentsRequest {
    /// All details necessary to construct the instance.
    /// The same instance parameter must be provided as in the corresponding R1CSRequest.
    instance          :GadgetInstance;

    /// The values that the parent assigned to `instance.incoming_variable_ids`.
    incoming_elements :[ubyte];

    /// Optional: The representation used for the incoming_elements, if non-default.
    representation    :FieldElementRepresentation;

    /// Optional: Any info that may be useful to the gadget to compute its assignments.
    witness           :[CustomKeyValue];
}

/// Report local and outgoing assignments computed by the gadget.
/// To send to the stream of assigned variables.
table AssignedVariables {
    /// The IDs of the variables being assigned to.
    variable_ids   :[uint64];

    /// Contiguous element representations in the same order as variable_ids.
    elements       :[ubyte];

    /// Optional: The representation used for the elements, if non-default.
    representation :FieldElementRepresentation;
}

/// Response after all AssignedVariables have been sent.
table AssignmentsResponse {
    /// First variable ID free after the gadget call.
    /// A variable ID greater than all IDs allocated by the gadget.
    free_variable_id_after :uint64;

    /// The values that the gadget assigned to `instance.outgoing_variable_ids`.
    /// Intentionally redundant with AssignedVariables to allow handling
    /// the outgoing variables separately from the bulk of local variables assignments.
    outgoing_elements      :[ubyte];

    /// Optional: The representation used for the outgoingAssignments, if non-default.
    representation         :FieldElementRepresentation;

    /// Optional: Any info that may be useful to the calling parent.
    info                   :[CustomKeyValue];

    /// Optional: An error message. Null if no error.
    error                  :string;
}


// == Flexibility Concept ==

/// Generic key-value for miscellaneous attributes.
table CustomKeyValue {
    key   :string;
    value :[ubyte];
}

/// Description of the representation or encoding of field elements.
/// All messages that transmit field elements should include it.
/// If omitted, assume the recommended representation:
/// name = "little-endian"
/// size = 32 bytes
///
/// There are two ways to use this information:
/// - Simply check it, and return an error if the representation is incorrect.
/// - Or write generic code that converts automatically when necessary.
///
table FieldElementRepresentation {
    /// The well-known name of the representation.
    name :string;

    /// Optional: The size of the representation of an element in bytes, if fixed-size.
    size :uint32;
}


// == Type Safety Concept ==
//
// The interface uses flat array of variables,
// because it is the lowest common denominator and
// is simple to implement in all situations.
//
// Typing information is provided as an overlay that describes the variables.
// A framework may omit or ignore typing information.
//

/// A high-level structure of variables for type safety.
/// A structure describes the semantics over a flat array of variables.
/// Define the interface between a gadget and the rest of the circuit.
/// In gadget composition, the parent provides these structures to its child.
/// A gadget should document what structures it can accept.
table StructuredConnection {
    /// How many variables make up this connection.
    variable_count :uint64;

    /// Optional: recursive type.
    /// The inner structures describe subsequent segments of the variables array.
    structures     :[StructuredConnection];

    /// Optional: Name of the connection.
    name           :string;

    /// Optional: Any custom information.
    info           :[CustomKeyValue];
}

/// A description of the types that a gadget expects.
/// Used to provide type safety.
table GadgetDescription {
    /// Name of the gadget.
    /// Use in other request to select a gadget.
    gadget_name           :string;

    // Describe the structure of the incoming array of variables.
    incoming_connection :StructuredConnection;

    // Describe the structure of the outgoing array of variables.
    outgoing_connection :StructuredConnection;

    /// The representations of field elements supported by this gadget.
    supported_representations      :[FieldElementRepresentation];

    /// Any custom information.
    info           :[CustomKeyValue];
}

// == Messages for type safety ==

table GadgetsDescriptionRequest {}

table GadgetsDescriptionResponse {
    gadgets :[GadgetDescription];
}
