namespace Gadget;

union Message {
    GadgetsDescriptionRequest,
    GadgetsDescriptionResponse,

    R1CSRequest,
    R1CSChunk,
    R1CSResponse,

    AssignmentsRequest,
    AssignmentsChunk,
    AssignmentsResponse,
}

table Root {
    message :Message;
}

root_type Root;


// == Types ==

// Variable ID = uint64
// Unique within a constraint system.
// Zero is a reserved special value.

/// Terms in a R1CS vector.
table Terms {
    // The IDs of the variables to constrain.
    variable_ids :[uint64];

    /// Contiguous coefficient representations in the same order as variable_ids.
    coefficients :[ubyte];
}

/// A low-level R1CS constraint between variables.
/// Targets the generic mechanisms that build circuits.
/// Intended to be sent in sequences.
table Constraint {
    // (A) * (B) = (C)
    a :Terms;
    b :Terms;
    c :Terms;
}

/// An instance of a gadget as part of a circuit.
table GadgetInstance {
    /// Which gadget to instantiate.
    /// Allows a library to provide multiple gadgets.
    gadget_name           :string;

    /// Variables allocated by the caller to use as connections to the gadget.
    /// Incoming variables are assigned by the calling parent.
    incoming_variable_ids :[uint64];

    /// Variables allocated by the caller to use as connections to the gadget.
    /// Outgoing variables are assigned by the called gadget.
    /// There may be no outgoing variables if the gadget represents a pure assertion.
    outgoing_variable_ids :[uint64];

    /// First free variable ID. The instance can allocate IDs greater or equal.
    free_variable_id      :uint64;

    /// Any parameter that may influence the instance behavior.
    /// Parameters can be standard, conventional, or specific to a gadget.
    parameters            :[CustomKeyValue];
}


// == Messages for Instantiation ==

/// Request to build an instance.
table R1CSRequest {
    /// All details necessary to construct the instance.
    /// The same instance parameter must be provided in the corresponding AssignmentsRequest.
    instance :GadgetInstance;
}

/// Report all constraints in one or more chunks.
table R1CSChunk {
    /// Constraints to add.
    constraints    :[Constraint];

    /// The representation used for the constraint coefficients.
    representation :FieldElementRepresentation;
}

/// Response after the instantiation is complete.
table R1CSResponse {
    /// A variable ID greater than all IDs allocated by the gadget.
    free_variable_id :uint64;

    /// Any info that may be useful to the calling parent.
    info             :[CustomKeyValue];

    /// An error message. Null if no error.
    error            :string;
}


// == Messages for Proving ==

/// Request assignments computed from a witness.
table AssignmentsRequest {
    /// All details necessary to construct the instance.
    /// The same instance parameter must be provided as in the corresponding R1CSRequest.
    instance          :GadgetInstance;

    /// The values that the parent assigned to `instance.incoming_variable_ids`.
    incoming_elements :[ubyte];

    /// The representation used for the incoming_elements.
    representation    :FieldElementRepresentation;

    /// Any info that may be useful to the gadget to compute its assignments.
    witness           :[CustomKeyValue];
}

/// Report local and outgoing assignments computed by the gadget.
/// There may be one or more chunks.
table AssignmentsChunk {
    /// The IDs of the variables being assigned to.
    variable_ids   :[uint64];

    /// Contiguous element representations in the same order as variable_ids.
    elements       :[ubyte];

    /// The representation used for the elements.
    representation :FieldElementRepresentation;
}

/// Response after all assignments have been reported.
table AssignmentsResponse {
    /// A variable ID greater than all IDs allocated by the instance.
    free_variable_id  :uint64;

    /// The values that the gadget assigned to `instance.outgoing_variable_ids`.
    /// Intentionally redundant with AssignmentsChunk to allow handling
    /// the outgoing variables separately from the bulk of local variables assignments.
    outgoing_elements :[ubyte];

    /// The representation used for the outgoingAssignments.
    representation    :FieldElementRepresentation;

    /// Any info that may be useful to the calling parent.
    info              :[CustomKeyValue];

    /// An error message. Null if no error.
    error             :string;
}


// == Flexibility Concept ==

/// Generic key-value for miscellaneous attributes.
table CustomKeyValue {
    key   :string;
    value :[ubyte];
}

/// Description of the representation or encoding of field elements.
/// All messages that transmit field elements should include it.
/// If omitted, assume the recommended representation:
/// name = "little-endian"
/// size = 32 bytes
///
/// There are two ways to use this information:
/// - Simply check it, and return an error if the representation is incorrect.
/// - Or write generic code that converts automatically when necessary.
///
table FieldElementRepresentation {
    /// The well-known name of the representation.
    name :string;

    /// The size of the representation of an element in bytes.
    size :uint32;
}


// == Type Safety Concept ==
//
// The interface uses flat array of variables,
// because it is the lowest common denominator and
// is simple to implement in all situations.
//
// Typing information is provided as an overlay that describes the variables.
// A framework may omit or ignore typing information.
//

/// A high-level structure of variables for type safety.
/// A structure describes the semantics over a flat array of variables.
/// Define the interface between a gadget and the rest of the circuit.
/// In gadget composition, the parent provides these structures to its child.
/// A gadget should document what structures it can accept.
table StructuredConnection {
    variable_count :[uint64];

    /// Optionally recursive type.
    /// If used, the field `variable_ids` must be null.
    structures     :[StructuredConnection];

    /// Name of the connection.
    name           :string;

    /// Any custom information.
    info           :[CustomKeyValue];
}

/// A description of the types that a gadget expects.
/// Used to provide type safety.
table GadgetDescription {
    /// Name of the gadget.
    /// Use in other request to select a gadget.
    gadget_name           :string;

    // Describe the structure of the incoming array of variables.
    incoming_connection :StructuredConnection;

    // Describe the structure of the outgoing array of variables.
    outgoing_connection :StructuredConnection;

    /// The representations of field elements supported by this gadget.
    supported_representations      :[FieldElementRepresentation];

    /// Any custom information.
    info           :[CustomKeyValue];
}

// == Messages for type safety ==

table GadgetsDescriptionRequest {

}

table GadgetsDescriptionResponse {
    gadgets :[GadgetDescription];
}
