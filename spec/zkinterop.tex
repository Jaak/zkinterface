\documentclass[a4paper,11pt]{article}

	%\input{style}
	
	\usepackage[notes=true]{lib/dtrt}
	\usepackage{algorithm}
	\usepackage{algpseudocode}
	\usepackage{amsmath}
	\usepackage{xcolor}
	\usepackage{graphicx}
	\usepackage{todonotes}
	\usepackage{listings}
	\usepackage{pxfonts}
	\usepackage[margin=1in]{geometry}

	\usepackage{lib/lang}  % include language definition for protobuf
	\usepackage{lib/style} % include custom style for proto declarations.	
	
	%\usepackage{sagetex}

	% Auuthor notes (using dtrt's macros). Switch the dtrt package flag to notes=false to hide.
	\definecolor{darkgreen}{rgb}{0,0.6,0}
	\newcommand{\dnote}[1]{\dtcolornote[Daniel]{red}{#1}}
	\newcommand{\anote}[1]{\dtcolornote[Aurell]{blue}{#1}}
	\newcommand{\enote}[1]{\dtcolornote[Eran]{darkgreen}{#1}}

	\newcommand\dtodo[1]{\todo[color=red!20]{#1}}
	\newcommand\atodo[1]{\todo[color=green!20]{#1}}
	\newcommand\etodo[1]{\todo[color=blue!20]{#1}}
	\def\boxit#1{%
		\smash{\color{red}\fboxrule=1pt\relax\fboxsep=-2pt\llap{\rlap{\fbox{\strut\makebox[#1]{}}}~}}\ignorespaces
	}
	
	%\makeatletter
	%\def\BState{\State\hskip-\ALG@thistlm}
	%\makeatother
	
	%opening
	\title{zkInterface, a tool for zero-knowledge interoperability}
	\author{Daniel Benarroch, Kobi Gurkan, Aurel Nicolas, Eran Tromer}
	
	\begin{document}
		
		\maketitle
		
		\enote{Add abstract}

%=============================================================================
\section{Overview}

%-----------------------------------------------------------------------------
\subsection{Background}
\enote{Rewrite:}
Implementing zero-knowledge proof constructions is not a trivial task and comes with diverse matters, as is extensively explained in the \href{https://zkproof.org/proceedings-snapshots/zkproof-implementation-20180801.pdf}{Implementation Track proceeding} of the first ZKProof workshop. One of the requirements is to create a compiler of programs into constraint systems that are consumed by the proving system.

There are several trade-offs one can consider when designing general-purpose (front-end) compilers, leading to distinct frameworks, APIs, generality, etc. Today, existing compilers are implemented to work best with their corresponding (back-end) proving system (somemetimes more than one). For a comprehensive list of front-ends and back-ends, you can go to \href{https://zkp.science}{zkp.science}. 

These libraries are usually built end-to-end: they take in some program that defines the statement and generate or verify a proof, in many cases without explicitly exposing the constraint system compilation. Moreover, if the compilers can output intermediary files and configurations, they are usually native to the specific back-end. In practice this means that
\begin{itemize}
	\item there is no portability between different proving systems and compilers, and
	\item it is not possible to compile a program using code from different frameworks
\end{itemize}   

%-----------------------------------------------------------------------------
\subsection{Goals}
\enote{Rewrite:}

\enote{Copy relevant text from the Implementation Track, especially Advanced Interoperability}

We aim to solve this issue, as seen in Figure \ref{interface}, by creating a community standard proposal for the ZKProof effort around constraint system formatting, building upon the work done at the first ZKProof workshop.

We design and implement a standard rank-1 constraint system (R1CS) interface between front-ends and back-ends. Our design encompasses programmable instance and witness reductions, while capturing the parameters of the different components of the statement to be proven. Given that these statements can be large and difficult to build, developers usually build smaller components that are re-usable with different statements; these components are sometimes called ``gadgets". With our zkInterface one can piece together programmatically the different components to form a complete statement.

\paragraph{Desiderata}
\begin{itemize}
	\item Interoperability across frontend frameworks and programming languages.
	\item Ability to write components that can be consumed by different frontends and backends.
	\item The overhead of the R1CS construction and witness reduction should be linear compared to a native implementation of the same gadgets .
        \item Expose details of the backend's interface that are necessary for performance (e.g., constraint system representation and algebraic fields).
	\item Appraoch can be extended to support constraint systems beyond R1CS.
\end{itemize}

\paragraph{Scope and limitations.} \enote{Rewrite:}

We aim for the standard interface to be as generic as possible, including non-R1CS-based proving systems. However, the current proposal is more limited, mainly due to time constraints.

The standard that we propose can be seen in three different levels:
\begin{enumerate}
	\item The first level defines  
	\begin{itemize}
		\item standard messages and their serialization that the caller and callee exchange, 
		\item a data format for R1CS constraints,
		\item a data format for R1CS variables assignments.
	\end{itemize}
	\item The second level defines a simple C API that allows for the exchange of messages.
	\item The third level defines the self-contained packaging of a component for its portable execution on different platforms.
\end{enumerate}

This proposal is not aiming to standardize a language or framework for generating constraint systems, nor the way that components of the proving statement should be written. However, it is important to point that any such framework could use the proposed interface.

\begin{figure}[h!]
	\includegraphics[width=\linewidth]{interface.png}
	\caption{zkInterface\enote{Replace by diagram on slack}}
	\label{interface}
\end{figure}

\input{design.tex}

%Rewriting \input{description.tex}

\subsection{Interface Definition}

	\lstinputlisting[
		caption=gadget.fbs - Interface definition,
		language=flatbuffers2,style=protobuf,
		label=gadget.fbs]{../gadget.fbs}

	\lstinputlisting[
		caption=gadget.h - C Interface,
		language=C++,style=protobuf,
		label=gadget.h]{../cpp/gadget.h}

\end{document}