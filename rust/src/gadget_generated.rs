// automatically generated by the FlatBuffers compiler, do not modify


pub mod gadget {
  #![allow(dead_code)]
  #![allow(unused_imports)]

  use std::mem;
  use std::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::EndianScalar;

#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Debug)]
pub enum Message {
  NONE = 0,
  R1CSConstraints = 1,
  AssignedVariables = 2,
  ComponentCall = 3,
  ComponentReturn = 4,
  GadgetsDescriptionRequest = 5,
  GadgetsDescriptionResponse = 6,

}

const ENUM_MIN_MESSAGE: u8 = 0;
const ENUM_MAX_MESSAGE: u8 = 6;

impl<'a> flatbuffers::Follow<'a> for Message {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for Message {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const Message;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const Message;
    unsafe { *p }
  }
}

impl flatbuffers::Push for Message {
    type Output = Message;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<Message>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_MESSAGE:[Message; 7] = [
  Message::NONE,
  Message::R1CSConstraints,
  Message::AssignedVariables,
  Message::ComponentCall,
  Message::ComponentReturn,
  Message::GadgetsDescriptionRequest,
  Message::GadgetsDescriptionResponse
];

#[allow(non_camel_case_types)]
const ENUM_NAMES_MESSAGE:[&'static str; 7] = [
    "NONE",
    "R1CSConstraints",
    "AssignedVariables",
    "ComponentCall",
    "ComponentReturn",
    "GadgetsDescriptionRequest",
    "GadgetsDescriptionResponse"
];

pub fn enum_name_message(e: Message) -> &'static str {
  let index: usize = e as usize;
  ENUM_NAMES_MESSAGE[index]
}

pub struct MessageUnionTableOffset {}
pub enum RootOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Root<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Root<'a> {
    type Inner = Root<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Root<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Root {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args RootArgs) -> flatbuffers::WIPOffset<Root<'bldr>> {
      let mut builder = RootBuilder::new(_fbb);
      if let Some(x) = args.message { builder.add_message(x); }
      builder.add_message_type(args.message_type);
      builder.finish()
    }

    pub const VT_MESSAGE_TYPE: flatbuffers::VOffsetT = 4;
    pub const VT_MESSAGE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn message_type(&self) -> Message {
    self._tab.get::<Message>(Root::VT_MESSAGE_TYPE, Some(Message::NONE)).unwrap()
  }
  #[inline]
  pub fn message(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Root::VT_MESSAGE, None)
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn message_as_r1csconstraints(&self) -> Option<R1CSConstraints<'a>> {
    if self.message_type() == Message::R1CSConstraints {
      self.message().map(|u| R1CSConstraints::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn message_as_assigned_variables(&self) -> Option<AssignedVariables<'a>> {
    if self.message_type() == Message::AssignedVariables {
      self.message().map(|u| AssignedVariables::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn message_as_component_call(&self) -> Option<ComponentCall<'a>> {
    if self.message_type() == Message::ComponentCall {
      self.message().map(|u| ComponentCall::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn message_as_component_return(&self) -> Option<ComponentReturn<'a>> {
    if self.message_type() == Message::ComponentReturn {
      self.message().map(|u| ComponentReturn::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn message_as_gadgets_description_request(&self) -> Option<GadgetsDescriptionRequest<'a>> {
    if self.message_type() == Message::GadgetsDescriptionRequest {
      self.message().map(|u| GadgetsDescriptionRequest::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn message_as_gadgets_description_response(&self) -> Option<GadgetsDescriptionResponse<'a>> {
    if self.message_type() == Message::GadgetsDescriptionResponse {
      self.message().map(|u| GadgetsDescriptionResponse::init_from_table(u))
    } else {
      None
    }
  }

}

pub struct RootArgs {
    pub message_type: Message,
    pub message: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for RootArgs {
    #[inline]
    fn default() -> Self {
        RootArgs {
            message_type: Message::NONE,
            message: None,
        }
    }
}
pub struct RootBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RootBuilder<'a, 'b> {
  #[inline]
  pub fn add_message_type(&mut self, message_type: Message) {
    self.fbb_.push_slot::<Message>(Root::VT_MESSAGE_TYPE, message_type, Message::NONE);
  }
  #[inline]
  pub fn add_message(&mut self, message: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Root::VT_MESSAGE, message);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RootBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RootBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Root<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

/// Concrete variable values.
/// Used for linear combinations and assignments.
pub enum VariableValuesOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct VariableValues<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for VariableValues<'a> {
    type Inner = VariableValues<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> VariableValues<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        VariableValues {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args VariableValuesArgs<'args>) -> flatbuffers::WIPOffset<VariableValues<'bldr>> {
      let mut builder = VariableValuesBuilder::new(_fbb);
      if let Some(x) = args.elements { builder.add_elements(x); }
      if let Some(x) = args.variable_ids { builder.add_variable_ids(x); }
      builder.finish()
    }

    pub const VT_VARIABLE_IDS: flatbuffers::VOffsetT = 4;
    pub const VT_ELEMENTS: flatbuffers::VOffsetT = 6;

  /// The IDs of the variables being assigned to.
  #[inline]
  pub fn variable_ids(&self) -> Option<flatbuffers::Vector<'a, u64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u64>>>(VariableValues::VT_VARIABLE_IDS, None)
  }
  /// Field Elements assigned to variables.
  /// Contiguous BigInts in the same order as variable_ids.
  ///
  /// The field in use is defined in `instance.field_order`.
  ///
  /// The size of an element representation is determined by:
  ///     element size = elements.length / variable_ids.length
  ///
  /// The element representation may be truncated and therefore shorter
  /// than the canonical representation. Truncated bytes are treated as zeros.
  #[inline]
  pub fn elements(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(VariableValues::VT_ELEMENTS, None).map(|v| v.safe_slice())
  }
}

pub struct VariableValuesArgs<'a> {
    pub variable_ids: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u64>>>,
    pub elements: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
}
impl<'a> Default for VariableValuesArgs<'a> {
    #[inline]
    fn default() -> Self {
        VariableValuesArgs {
            variable_ids: None,
            elements: None,
        }
    }
}
pub struct VariableValuesBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> VariableValuesBuilder<'a, 'b> {
  #[inline]
  pub fn add_variable_ids(&mut self, variable_ids: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(VariableValues::VT_VARIABLE_IDS, variable_ids);
  }
  #[inline]
  pub fn add_elements(&mut self, elements: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(VariableValues::VT_ELEMENTS, elements);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> VariableValuesBuilder<'a, 'b> {
    let start = _fbb.start_table();
    VariableValuesBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<VariableValues<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

/// An R1CS constraint between variables.
pub enum ConstraintOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Constraint<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Constraint<'a> {
    type Inner = Constraint<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Constraint<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Constraint {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ConstraintArgs<'args>) -> flatbuffers::WIPOffset<Constraint<'bldr>> {
      let mut builder = ConstraintBuilder::new(_fbb);
      if let Some(x) = args.linear_combination_c { builder.add_linear_combination_c(x); }
      if let Some(x) = args.linear_combination_b { builder.add_linear_combination_b(x); }
      if let Some(x) = args.linear_combination_a { builder.add_linear_combination_a(x); }
      builder.finish()
    }

    pub const VT_LINEAR_COMBINATION_A: flatbuffers::VOffsetT = 4;
    pub const VT_LINEAR_COMBINATION_B: flatbuffers::VOffsetT = 6;
    pub const VT_LINEAR_COMBINATION_C: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn linear_combination_a(&self) -> Option<VariableValues<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<VariableValues<'a>>>(Constraint::VT_LINEAR_COMBINATION_A, None)
  }
  #[inline]
  pub fn linear_combination_b(&self) -> Option<VariableValues<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<VariableValues<'a>>>(Constraint::VT_LINEAR_COMBINATION_B, None)
  }
  #[inline]
  pub fn linear_combination_c(&self) -> Option<VariableValues<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<VariableValues<'a>>>(Constraint::VT_LINEAR_COMBINATION_C, None)
  }
}

pub struct ConstraintArgs<'a> {
    pub linear_combination_a: Option<flatbuffers::WIPOffset<VariableValues<'a >>>,
    pub linear_combination_b: Option<flatbuffers::WIPOffset<VariableValues<'a >>>,
    pub linear_combination_c: Option<flatbuffers::WIPOffset<VariableValues<'a >>>,
}
impl<'a> Default for ConstraintArgs<'a> {
    #[inline]
    fn default() -> Self {
        ConstraintArgs {
            linear_combination_a: None,
            linear_combination_b: None,
            linear_combination_c: None,
        }
    }
}
pub struct ConstraintBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ConstraintBuilder<'a, 'b> {
  #[inline]
  pub fn add_linear_combination_a(&mut self, linear_combination_a: flatbuffers::WIPOffset<VariableValues<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<VariableValues>>(Constraint::VT_LINEAR_COMBINATION_A, linear_combination_a);
  }
  #[inline]
  pub fn add_linear_combination_b(&mut self, linear_combination_b: flatbuffers::WIPOffset<VariableValues<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<VariableValues>>(Constraint::VT_LINEAR_COMBINATION_B, linear_combination_b);
  }
  #[inline]
  pub fn add_linear_combination_c(&mut self, linear_combination_c: flatbuffers::WIPOffset<VariableValues<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<VariableValues>>(Constraint::VT_LINEAR_COMBINATION_C, linear_combination_c);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ConstraintBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ConstraintBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Constraint<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

/// Description of a particular instance of a gadget.
pub enum GadgetInstanceOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct GadgetInstance<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GadgetInstance<'a> {
    type Inner = GadgetInstance<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> GadgetInstance<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GadgetInstance {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GadgetInstanceArgs<'args>) -> flatbuffers::WIPOffset<GadgetInstance<'bldr>> {
      let mut builder = GadgetInstanceBuilder::new(_fbb);
      builder.add_free_variable_id_before(args.free_variable_id_before);
      if let Some(x) = args.configuration { builder.add_configuration(x); }
      if let Some(x) = args.field_order { builder.add_field_order(x); }
      if let Some(x) = args.outgoing_variable_ids { builder.add_outgoing_variable_ids(x); }
      if let Some(x) = args.incoming_variable_ids { builder.add_incoming_variable_ids(x); }
      if let Some(x) = args.gadget_name { builder.add_gadget_name(x); }
      builder.finish()
    }

    pub const VT_GADGET_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_INCOMING_VARIABLE_IDS: flatbuffers::VOffsetT = 6;
    pub const VT_OUTGOING_VARIABLE_IDS: flatbuffers::VOffsetT = 8;
    pub const VT_FREE_VARIABLE_ID_BEFORE: flatbuffers::VOffsetT = 10;
    pub const VT_FIELD_ORDER: flatbuffers::VOffsetT = 12;
    pub const VT_CONFIGURATION: flatbuffers::VOffsetT = 14;

  /// Which gadget to instantiate.
  /// Allows a library to provide multiple gadgets.
  #[inline]
  pub fn gadget_name(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GadgetInstance::VT_GADGET_NAME, None)
  }
  /// Incoming Variables to use as connections to the gadget.
  /// Allocated by the caller.
  /// Assigned by the caller in `Witness.incoming_elements`.
  #[inline]
  pub fn incoming_variable_ids(&self) -> Option<flatbuffers::Vector<'a, u64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u64>>>(GadgetInstance::VT_INCOMING_VARIABLE_IDS, None)
  }
  /// Outgoing Variables to use as connections to the gadget.
  /// There may be no Outgoing Variables if the gadget is a pure assertion.
  /// Allocated by the caller.
  /// Assigned by the called gadget in `ComponentReturn.outgoing_elements`.
  #[inline]
  pub fn outgoing_variable_ids(&self) -> Option<flatbuffers::Vector<'a, u64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u64>>>(GadgetInstance::VT_OUTGOING_VARIABLE_IDS, None)
  }
  /// First free Variable ID before the call.
  /// The gadget can allocate new Variable IDs starting with this one.
  #[inline]
  pub fn free_variable_id_before(&self) -> u64 {
    self._tab.get::<u64>(GadgetInstance::VT_FREE_VARIABLE_ID_BEFORE, Some(0)).unwrap()
  }
  /// The order of the field used by the current system.
  /// A BigInt.
  #[inline]
  pub fn field_order(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(GadgetInstance::VT_FIELD_ORDER, None).map(|v| v.safe_slice())
  }
  /// Optional: Any static parameter that may influence the instance construction.
  /// Parameters can be standard, conventional, or specific to a gadget.
  /// Example: the depth of a Merkle tree.
  /// Counter-example: the Merkle authentication path is not configuration (rather witness).
  #[inline]
  pub fn configuration(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CustomKeyValue<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<CustomKeyValue<'a>>>>>(GadgetInstance::VT_CONFIGURATION, None)
  }
}

pub struct GadgetInstanceArgs<'a> {
    pub gadget_name: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub incoming_variable_ids: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u64>>>,
    pub outgoing_variable_ids: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u64>>>,
    pub free_variable_id_before: u64,
    pub field_order: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
    pub configuration: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<CustomKeyValue<'a >>>>>,
}
impl<'a> Default for GadgetInstanceArgs<'a> {
    #[inline]
    fn default() -> Self {
        GadgetInstanceArgs {
            gadget_name: None,
            incoming_variable_ids: None,
            outgoing_variable_ids: None,
            free_variable_id_before: 0,
            field_order: None,
            configuration: None,
        }
    }
}
pub struct GadgetInstanceBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GadgetInstanceBuilder<'a, 'b> {
  #[inline]
  pub fn add_gadget_name(&mut self, gadget_name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GadgetInstance::VT_GADGET_NAME, gadget_name);
  }
  #[inline]
  pub fn add_incoming_variable_ids(&mut self, incoming_variable_ids: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GadgetInstance::VT_INCOMING_VARIABLE_IDS, incoming_variable_ids);
  }
  #[inline]
  pub fn add_outgoing_variable_ids(&mut self, outgoing_variable_ids: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GadgetInstance::VT_OUTGOING_VARIABLE_IDS, outgoing_variable_ids);
  }
  #[inline]
  pub fn add_free_variable_id_before(&mut self, free_variable_id_before: u64) {
    self.fbb_.push_slot::<u64>(GadgetInstance::VT_FREE_VARIABLE_ID_BEFORE, free_variable_id_before, 0);
  }
  #[inline]
  pub fn add_field_order(&mut self, field_order: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GadgetInstance::VT_FIELD_ORDER, field_order);
  }
  #[inline]
  pub fn add_configuration(&mut self, configuration: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<CustomKeyValue<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GadgetInstance::VT_CONFIGURATION, configuration);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GadgetInstanceBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GadgetInstanceBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GadgetInstance<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

/// Generic key-value for custom attributes.
pub enum CustomKeyValueOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct CustomKeyValue<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CustomKeyValue<'a> {
    type Inner = CustomKeyValue<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> CustomKeyValue<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        CustomKeyValue {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args CustomKeyValueArgs<'args>) -> flatbuffers::WIPOffset<CustomKeyValue<'bldr>> {
      let mut builder = CustomKeyValueBuilder::new(_fbb);
      if let Some(x) = args.value { builder.add_value(x); }
      if let Some(x) = args.key { builder.add_key(x); }
      builder.finish()
    }

    pub const VT_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn key(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CustomKeyValue::VT_KEY, None)
  }
  #[inline]
  pub fn value(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(CustomKeyValue::VT_VALUE, None).map(|v| v.safe_slice())
  }
}

pub struct CustomKeyValueArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub value: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
}
impl<'a> Default for CustomKeyValueArgs<'a> {
    #[inline]
    fn default() -> Self {
        CustomKeyValueArgs {
            key: None,
            value: None,
        }
    }
}
pub struct CustomKeyValueBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> CustomKeyValueBuilder<'a, 'b> {
  #[inline]
  pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CustomKeyValue::VT_KEY, key);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CustomKeyValue::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> CustomKeyValueBuilder<'a, 'b> {
    let start = _fbb.start_table();
    CustomKeyValueBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CustomKeyValue<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

/// Report constraints to be added to the constraints system.
/// To send to the stream of constraints.
pub enum R1CSConstraintsOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct R1CSConstraints<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for R1CSConstraints<'a> {
    type Inner = R1CSConstraints<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> R1CSConstraints<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        R1CSConstraints {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args R1CSConstraintsArgs<'args>) -> flatbuffers::WIPOffset<R1CSConstraints<'bldr>> {
      let mut builder = R1CSConstraintsBuilder::new(_fbb);
      if let Some(x) = args.constraints { builder.add_constraints(x); }
      builder.finish()
    }

    pub const VT_CONSTRAINTS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn constraints(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Constraint<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Constraint<'a>>>>>(R1CSConstraints::VT_CONSTRAINTS, None)
  }
}

pub struct R1CSConstraintsArgs<'a> {
    pub constraints: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<Constraint<'a >>>>>,
}
impl<'a> Default for R1CSConstraintsArgs<'a> {
    #[inline]
    fn default() -> Self {
        R1CSConstraintsArgs {
            constraints: None,
        }
    }
}
pub struct R1CSConstraintsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> R1CSConstraintsBuilder<'a, 'b> {
  #[inline]
  pub fn add_constraints(&mut self, constraints: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Constraint<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(R1CSConstraints::VT_CONSTRAINTS, constraints);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> R1CSConstraintsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    R1CSConstraintsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<R1CSConstraints<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

/// Report local assignments computed by the gadget.
/// To send to the stream of assigned variables.
/// Does not include input and output variables.
pub enum AssignedVariablesOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct AssignedVariables<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AssignedVariables<'a> {
    type Inner = AssignedVariables<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> AssignedVariables<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        AssignedVariables {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args AssignedVariablesArgs<'args>) -> flatbuffers::WIPOffset<AssignedVariables<'bldr>> {
      let mut builder = AssignedVariablesBuilder::new(_fbb);
      if let Some(x) = args.values { builder.add_values(x); }
      builder.finish()
    }

    pub const VT_VALUES: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn values(&self) -> Option<VariableValues<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<VariableValues<'a>>>(AssignedVariables::VT_VALUES, None)
  }
}

pub struct AssignedVariablesArgs<'a> {
    pub values: Option<flatbuffers::WIPOffset<VariableValues<'a >>>,
}
impl<'a> Default for AssignedVariablesArgs<'a> {
    #[inline]
    fn default() -> Self {
        AssignedVariablesArgs {
            values: None,
        }
    }
}
pub struct AssignedVariablesBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> AssignedVariablesBuilder<'a, 'b> {
  #[inline]
  pub fn add_values(&mut self, values: flatbuffers::WIPOffset<VariableValues<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<VariableValues>>(AssignedVariables::VT_VALUES, values);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> AssignedVariablesBuilder<'a, 'b> {
    let start = _fbb.start_table();
    AssignedVariablesBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<AssignedVariables<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum ComponentCallOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct ComponentCall<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ComponentCall<'a> {
    type Inner = ComponentCall<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> ComponentCall<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ComponentCall {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ComponentCallArgs<'args>) -> flatbuffers::WIPOffset<ComponentCall<'bldr>> {
      let mut builder = ComponentCallBuilder::new(_fbb);
      if let Some(x) = args.generate_assignment { builder.add_generate_assignment(x); }
      if let Some(x) = args.instance { builder.add_instance(x); }
      builder.add_generate_r1cs(args.generate_r1cs);
      builder.finish()
    }

    pub const VT_INSTANCE: flatbuffers::VOffsetT = 4;
    pub const VT_GENERATE_R1CS: flatbuffers::VOffsetT = 6;
    pub const VT_GENERATE_ASSIGNMENT: flatbuffers::VOffsetT = 8;

  /// All details necessary to construct the instance.
  /// The same instance must be provided for R1CS and assignment generation.
  #[inline]
  pub fn instance(&self) -> Option<GadgetInstance<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<GadgetInstance<'a>>>(ComponentCall::VT_INSTANCE, None)
  }
  /// Whether constraints should be generated.
  #[inline]
  pub fn generate_r1cs(&self) -> bool {
    self._tab.get::<bool>(ComponentCall::VT_GENERATE_R1CS, Some(false)).unwrap()
  }
  /// Whether an assignment should be generated.
  /// Provide witness values to the component.
  #[inline]
  pub fn generate_assignment(&self) -> Option<Witness<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Witness<'a>>>(ComponentCall::VT_GENERATE_ASSIGNMENT, None)
  }
}

pub struct ComponentCallArgs<'a> {
    pub instance: Option<flatbuffers::WIPOffset<GadgetInstance<'a >>>,
    pub generate_r1cs: bool,
    pub generate_assignment: Option<flatbuffers::WIPOffset<Witness<'a >>>,
}
impl<'a> Default for ComponentCallArgs<'a> {
    #[inline]
    fn default() -> Self {
        ComponentCallArgs {
            instance: None,
            generate_r1cs: false,
            generate_assignment: None,
        }
    }
}
pub struct ComponentCallBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ComponentCallBuilder<'a, 'b> {
  #[inline]
  pub fn add_instance(&mut self, instance: flatbuffers::WIPOffset<GadgetInstance<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<GadgetInstance>>(ComponentCall::VT_INSTANCE, instance);
  }
  #[inline]
  pub fn add_generate_r1cs(&mut self, generate_r1cs: bool) {
    self.fbb_.push_slot::<bool>(ComponentCall::VT_GENERATE_R1CS, generate_r1cs, false);
  }
  #[inline]
  pub fn add_generate_assignment(&mut self, generate_assignment: flatbuffers::WIPOffset<Witness<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Witness>>(ComponentCall::VT_GENERATE_ASSIGNMENT, generate_assignment);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ComponentCallBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ComponentCallBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ComponentCall<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

/// Details necessary to compute an assignment.
pub enum WitnessOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Witness<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Witness<'a> {
    type Inner = Witness<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Witness<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Witness {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args WitnessArgs<'args>) -> flatbuffers::WIPOffset<Witness<'bldr>> {
      let mut builder = WitnessBuilder::new(_fbb);
      if let Some(x) = args.info { builder.add_info(x); }
      if let Some(x) = args.incoming_elements { builder.add_incoming_elements(x); }
      builder.finish()
    }

    pub const VT_INCOMING_ELEMENTS: flatbuffers::VOffsetT = 4;
    pub const VT_INFO: flatbuffers::VOffsetT = 6;

  /// The values that the caller assigned to Incoming Variables.
  /// Contiguous BigInts in the same order as `instance.incoming_variable_ids`.
  #[inline]
  pub fn incoming_elements(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Witness::VT_INCOMING_ELEMENTS, None).map(|v| v.safe_slice())
  }
  /// Optional: Any info that may be useful to the gadget to compute its assignments.
  /// Example: Merkle authentication path.
  #[inline]
  pub fn info(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CustomKeyValue<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<CustomKeyValue<'a>>>>>(Witness::VT_INFO, None)
  }
}

pub struct WitnessArgs<'a> {
    pub incoming_elements: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
    pub info: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<CustomKeyValue<'a >>>>>,
}
impl<'a> Default for WitnessArgs<'a> {
    #[inline]
    fn default() -> Self {
        WitnessArgs {
            incoming_elements: None,
            info: None,
        }
    }
}
pub struct WitnessBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> WitnessBuilder<'a, 'b> {
  #[inline]
  pub fn add_incoming_elements(&mut self, incoming_elements: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Witness::VT_INCOMING_ELEMENTS, incoming_elements);
  }
  #[inline]
  pub fn add_info(&mut self, info: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<CustomKeyValue<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Witness::VT_INFO, info);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> WitnessBuilder<'a, 'b> {
    let start = _fbb.start_table();
    WitnessBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Witness<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

/// Response after all R1CSConstraints or AssignedVariables have been sent.
pub enum ComponentReturnOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct ComponentReturn<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ComponentReturn<'a> {
    type Inner = ComponentReturn<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> ComponentReturn<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ComponentReturn {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ComponentReturnArgs<'args>) -> flatbuffers::WIPOffset<ComponentReturn<'bldr>> {
      let mut builder = ComponentReturnBuilder::new(_fbb);
      builder.add_free_variable_id_after(args.free_variable_id_after);
      if let Some(x) = args.outgoing_elements { builder.add_outgoing_elements(x); }
      if let Some(x) = args.error { builder.add_error(x); }
      if let Some(x) = args.info { builder.add_info(x); }
      builder.finish()
    }

    pub const VT_FREE_VARIABLE_ID_AFTER: flatbuffers::VOffsetT = 4;
    pub const VT_INFO: flatbuffers::VOffsetT = 6;
    pub const VT_ERROR: flatbuffers::VOffsetT = 8;
    pub const VT_OUTGOING_ELEMENTS: flatbuffers::VOffsetT = 10;

  /// First variable ID free after the gadget call.
  /// A variable ID greater than all IDs allocated by the gadget.
  #[inline]
  pub fn free_variable_id_after(&self) -> u64 {
    self._tab.get::<u64>(ComponentReturn::VT_FREE_VARIABLE_ID_AFTER, Some(0)).unwrap()
  }
  /// Optional: Any info that may be useful to the caller.
  #[inline]
  pub fn info(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CustomKeyValue<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<CustomKeyValue<'a>>>>>(ComponentReturn::VT_INFO, None)
  }
  /// Optional: An error message. Null if no error.
  #[inline]
  pub fn error(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ComponentReturn::VT_ERROR, None)
  }
  /// The values that the gadget assigned to outgoing variables, if any.
  /// Contiguous BigInts in the same order as `instance.outgoing_variable_ids`.
  #[inline]
  pub fn outgoing_elements(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(ComponentReturn::VT_OUTGOING_ELEMENTS, None).map(|v| v.safe_slice())
  }
}

pub struct ComponentReturnArgs<'a> {
    pub free_variable_id_after: u64,
    pub info: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<CustomKeyValue<'a >>>>>,
    pub error: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub outgoing_elements: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
}
impl<'a> Default for ComponentReturnArgs<'a> {
    #[inline]
    fn default() -> Self {
        ComponentReturnArgs {
            free_variable_id_after: 0,
            info: None,
            error: None,
            outgoing_elements: None,
        }
    }
}
pub struct ComponentReturnBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ComponentReturnBuilder<'a, 'b> {
  #[inline]
  pub fn add_free_variable_id_after(&mut self, free_variable_id_after: u64) {
    self.fbb_.push_slot::<u64>(ComponentReturn::VT_FREE_VARIABLE_ID_AFTER, free_variable_id_after, 0);
  }
  #[inline]
  pub fn add_info(&mut self, info: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<CustomKeyValue<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ComponentReturn::VT_INFO, info);
  }
  #[inline]
  pub fn add_error(&mut self, error: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ComponentReturn::VT_ERROR, error);
  }
  #[inline]
  pub fn add_outgoing_elements(&mut self, outgoing_elements: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ComponentReturn::VT_OUTGOING_ELEMENTS, outgoing_elements);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ComponentReturnBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ComponentReturnBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ComponentReturn<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

/// A high-level structure of variables for type safety.
/// A structure describes the semantics over a flat array of variables.
/// Define the interface between a gadget and the rest of the circuit.
/// In gadget composition, the parent provides these structures to its child.
/// A gadget should document what structures it can accept.
pub enum StructuredConnectionOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct StructuredConnection<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for StructuredConnection<'a> {
    type Inner = StructuredConnection<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> StructuredConnection<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        StructuredConnection {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args StructuredConnectionArgs<'args>) -> flatbuffers::WIPOffset<StructuredConnection<'bldr>> {
      let mut builder = StructuredConnectionBuilder::new(_fbb);
      builder.add_variable_count(args.variable_count);
      if let Some(x) = args.info { builder.add_info(x); }
      if let Some(x) = args.name { builder.add_name(x); }
      if let Some(x) = args.structures { builder.add_structures(x); }
      builder.finish()
    }

    pub const VT_VARIABLE_COUNT: flatbuffers::VOffsetT = 4;
    pub const VT_STRUCTURES: flatbuffers::VOffsetT = 6;
    pub const VT_NAME: flatbuffers::VOffsetT = 8;
    pub const VT_INFO: flatbuffers::VOffsetT = 10;

  /// How many variables make up this connection.
  #[inline]
  pub fn variable_count(&self) -> u64 {
    self._tab.get::<u64>(StructuredConnection::VT_VARIABLE_COUNT, Some(0)).unwrap()
  }
  /// Optional: recursive type.
  /// The inner structures describe subsequent segments of the variables array.
  #[inline]
  pub fn structures(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StructuredConnection<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<StructuredConnection<'a>>>>>(StructuredConnection::VT_STRUCTURES, None)
  }
  /// Optional: Name of the connection.
  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(StructuredConnection::VT_NAME, None)
  }
  /// Optional: Any custom information.
  #[inline]
  pub fn info(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CustomKeyValue<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<CustomKeyValue<'a>>>>>(StructuredConnection::VT_INFO, None)
  }
}

pub struct StructuredConnectionArgs<'a> {
    pub variable_count: u64,
    pub structures: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<StructuredConnection<'a >>>>>,
    pub name: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub info: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<CustomKeyValue<'a >>>>>,
}
impl<'a> Default for StructuredConnectionArgs<'a> {
    #[inline]
    fn default() -> Self {
        StructuredConnectionArgs {
            variable_count: 0,
            structures: None,
            name: None,
            info: None,
        }
    }
}
pub struct StructuredConnectionBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> StructuredConnectionBuilder<'a, 'b> {
  #[inline]
  pub fn add_variable_count(&mut self, variable_count: u64) {
    self.fbb_.push_slot::<u64>(StructuredConnection::VT_VARIABLE_COUNT, variable_count, 0);
  }
  #[inline]
  pub fn add_structures(&mut self, structures: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<StructuredConnection<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StructuredConnection::VT_STRUCTURES, structures);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StructuredConnection::VT_NAME, name);
  }
  #[inline]
  pub fn add_info(&mut self, info: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<CustomKeyValue<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StructuredConnection::VT_INFO, info);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> StructuredConnectionBuilder<'a, 'b> {
    let start = _fbb.start_table();
    StructuredConnectionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<StructuredConnection<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

/// A description of the types that a gadget expects.
/// Used to provide type safety.
pub enum GadgetDescriptionOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct GadgetDescription<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GadgetDescription<'a> {
    type Inner = GadgetDescription<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> GadgetDescription<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GadgetDescription {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GadgetDescriptionArgs<'args>) -> flatbuffers::WIPOffset<GadgetDescription<'bldr>> {
      let mut builder = GadgetDescriptionBuilder::new(_fbb);
      if let Some(x) = args.info { builder.add_info(x); }
      if let Some(x) = args.outgoing_connection { builder.add_outgoing_connection(x); }
      if let Some(x) = args.incoming_connection { builder.add_incoming_connection(x); }
      if let Some(x) = args.gadget_name { builder.add_gadget_name(x); }
      builder.finish()
    }

    pub const VT_GADGET_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_INCOMING_CONNECTION: flatbuffers::VOffsetT = 6;
    pub const VT_OUTGOING_CONNECTION: flatbuffers::VOffsetT = 8;
    pub const VT_INFO: flatbuffers::VOffsetT = 10;

  /// Name of the gadget.
  /// Use in other request to select a gadget.
  #[inline]
  pub fn gadget_name(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GadgetDescription::VT_GADGET_NAME, None)
  }
  /// Describe the structure of the incoming array of variables.
  #[inline]
  pub fn incoming_connection(&self) -> Option<StructuredConnection<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<StructuredConnection<'a>>>(GadgetDescription::VT_INCOMING_CONNECTION, None)
  }
  /// Describe the structure of the outgoing array of variables.
  #[inline]
  pub fn outgoing_connection(&self) -> Option<StructuredConnection<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<StructuredConnection<'a>>>(GadgetDescription::VT_OUTGOING_CONNECTION, None)
  }
  /// Any custom information.
  #[inline]
  pub fn info(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CustomKeyValue<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<CustomKeyValue<'a>>>>>(GadgetDescription::VT_INFO, None)
  }
}

pub struct GadgetDescriptionArgs<'a> {
    pub gadget_name: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub incoming_connection: Option<flatbuffers::WIPOffset<StructuredConnection<'a >>>,
    pub outgoing_connection: Option<flatbuffers::WIPOffset<StructuredConnection<'a >>>,
    pub info: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<CustomKeyValue<'a >>>>>,
}
impl<'a> Default for GadgetDescriptionArgs<'a> {
    #[inline]
    fn default() -> Self {
        GadgetDescriptionArgs {
            gadget_name: None,
            incoming_connection: None,
            outgoing_connection: None,
            info: None,
        }
    }
}
pub struct GadgetDescriptionBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GadgetDescriptionBuilder<'a, 'b> {
  #[inline]
  pub fn add_gadget_name(&mut self, gadget_name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GadgetDescription::VT_GADGET_NAME, gadget_name);
  }
  #[inline]
  pub fn add_incoming_connection(&mut self, incoming_connection: flatbuffers::WIPOffset<StructuredConnection<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<StructuredConnection>>(GadgetDescription::VT_INCOMING_CONNECTION, incoming_connection);
  }
  #[inline]
  pub fn add_outgoing_connection(&mut self, outgoing_connection: flatbuffers::WIPOffset<StructuredConnection<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<StructuredConnection>>(GadgetDescription::VT_OUTGOING_CONNECTION, outgoing_connection);
  }
  #[inline]
  pub fn add_info(&mut self, info: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<CustomKeyValue<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GadgetDescription::VT_INFO, info);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GadgetDescriptionBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GadgetDescriptionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GadgetDescription<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum GadgetsDescriptionRequestOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct GadgetsDescriptionRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GadgetsDescriptionRequest<'a> {
    type Inner = GadgetsDescriptionRequest<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> GadgetsDescriptionRequest<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GadgetsDescriptionRequest {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        _args: &'args GadgetsDescriptionRequestArgs) -> flatbuffers::WIPOffset<GadgetsDescriptionRequest<'bldr>> {
      let mut builder = GadgetsDescriptionRequestBuilder::new(_fbb);
      builder.finish()
    }

}

pub struct GadgetsDescriptionRequestArgs {
}
impl<'a> Default for GadgetsDescriptionRequestArgs {
    #[inline]
    fn default() -> Self {
        GadgetsDescriptionRequestArgs {
        }
    }
}
pub struct GadgetsDescriptionRequestBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GadgetsDescriptionRequestBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GadgetsDescriptionRequestBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GadgetsDescriptionRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GadgetsDescriptionRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum GadgetsDescriptionResponseOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct GadgetsDescriptionResponse<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GadgetsDescriptionResponse<'a> {
    type Inner = GadgetsDescriptionResponse<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> GadgetsDescriptionResponse<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GadgetsDescriptionResponse {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GadgetsDescriptionResponseArgs<'args>) -> flatbuffers::WIPOffset<GadgetsDescriptionResponse<'bldr>> {
      let mut builder = GadgetsDescriptionResponseBuilder::new(_fbb);
      if let Some(x) = args.gadgets { builder.add_gadgets(x); }
      builder.finish()
    }

    pub const VT_GADGETS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn gadgets(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GadgetDescription<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<GadgetDescription<'a>>>>>(GadgetsDescriptionResponse::VT_GADGETS, None)
  }
}

pub struct GadgetsDescriptionResponseArgs<'a> {
    pub gadgets: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<GadgetDescription<'a >>>>>,
}
impl<'a> Default for GadgetsDescriptionResponseArgs<'a> {
    #[inline]
    fn default() -> Self {
        GadgetsDescriptionResponseArgs {
            gadgets: None,
        }
    }
}
pub struct GadgetsDescriptionResponseBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GadgetsDescriptionResponseBuilder<'a, 'b> {
  #[inline]
  pub fn add_gadgets(&mut self, gadgets: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<GadgetDescription<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GadgetsDescriptionResponse::VT_GADGETS, gadgets);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GadgetsDescriptionResponseBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GadgetsDescriptionResponseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GadgetsDescriptionResponse<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

#[inline]
pub fn get_root_as_root<'a>(buf: &'a [u8]) -> Root<'a> {
  flatbuffers::get_root::<Root<'a>>(buf)
}

#[inline]
pub fn get_size_prefixed_root_as_root<'a>(buf: &'a [u8]) -> Root<'a> {
  flatbuffers::get_size_prefixed_root::<Root<'a>>(buf)
}

pub const ROOT_IDENTIFIER: &'static str = "zkco";

#[inline]
pub fn root_buffer_has_identifier(buf: &[u8]) -> bool {
  return flatbuffers::buffer_has_identifier(buf, ROOT_IDENTIFIER, false);
}

#[inline]
pub fn root_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  return flatbuffers::buffer_has_identifier(buf, ROOT_IDENTIFIER, true);
}

pub const ROOT_EXTENSION: &'static str = "zkco";

#[inline]
pub fn finish_root_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<Root<'a>>) {
  fbb.finish(root, Some(ROOT_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_root_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<Root<'a>>) {
  fbb.finish_size_prefixed(root, Some(ROOT_IDENTIFIER));
}
}  // pub mod Gadget

